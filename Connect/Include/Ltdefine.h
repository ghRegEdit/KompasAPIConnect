////////////////////////////////////////////////////////////////////////////////
//
// LTDEFINE.H  
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __LTDEFINE_H
#define __LTDEFINE_H
#pragma pack( push, 1)


#ifdef BUILDER_COMPILER
#ifndef __WINDOWS_H
#include <windows.h>
#endif
#endif

#ifndef __LDEFIN2D_H
#include "ldefin2d.h"
#endif

// см. <ldefin2d.h> ErrorType - типы ошибок

//-------------------------------------------------------------------------------
// структура для сдвига группы
// ---
struct Type1 {
  double    xBase, yBase;
  double    ang;
  double    scale;
	reference gr;
};

//-------------------------------------------------------------------------------
// структура для отрезка
// ---
struct Type2 {
  double    xBase, yBase;
};

//-------------------------------------------------------------------------------
// структура для прямоугольника
// структура для отрезка c заданным углом
// ---
struct Type3 {
  double    xBase, yBase;
  double    ang;
};

//-------------------------------------------------------------------------------
// структура для половины прямоугольника c заданным углом
// ---
struct Type5 {
  double    xBase, yBase;
  double    ang;
  unsigned char horizon;  //1 подходим к курсору по горизонтвли; 0 - повертикали
};

//-------------------------------------------------------------------------------
// пользовательский фантом (только рисовать группу, матрицу сдвига не устанавливать)
// ---
struct Type6 {
	reference gr;  //указатель на группу объектов, которая отображается в виде фантома
};

//-------------------------------------------------------------------------------
//
// ---
struct Phantom {
  unsigned short      phType;  // тип резинки
  union  { //параметры резинки
    struct Type1 type1;    //сдвиг группы  phType =1
    struct Type2 type2;    //отрезок       phType =2
    struct Type3 type3;    //прямоугольник phType =3
    struct Type3 type4;    //отрезок с заданным углом phType =4
    struct Type5 type5;    //половина прямоугольника phType =5
    struct Type6 type6;    //пользовательский фантом (только рисовать группу, матрицу сдвига не устанавливать) phType =6
    struct Type2 type7;    //окружность   phType =7
  };
};

//-------------------------------------------------------------------------------
// структура местоположения
// ---
struct PlacementParam {
  double    xBase, yBase;  //базовая точка  в СК вида
  double    scale;         //масштаб
  double    ang;           //угол поворота  в СК вида
};

// см. <ldefin2d.h> ODBC_DB ...

// см. <ldefin2d.h> TXT_CHAR ...

// см. <ldefin2d.h> stACTIVE ... - состояние для вида, слоя, документа

// см. <ldefin2d.h> Определения для функции ksSytemPath
// sptSYSTEM_FILES ...

// см. <ldefin2d.h> Определения для результата функции SystemControlStart
// scsSTOPPED_FOR_MENU_COMMAND ...

//-------------------------------------------------------------------------------
// Структура параметров вида
// ---
struct ViewParam {
  unsigned short state;             // состояние вида
  double         x,y;               // точка привязки вида
  double         scale;             // масштаб вида
  double         ang;               // угол поворота вида
  unsigned long  color;             // цвет вида в активном состоянии
	char           name[TEXT_LENGTH]; // имя вида
};

//-------------------------------------------------------------------------------
// Структура параметров вида ( Unicode )
// ---
struct ViewParamW {
  unsigned short state;             // состояние вида
  double         x,y;               // точка привязки вида
  double         scale;             // масштаб вида
  double         ang;               // угол поворота вида
  unsigned long  color;             // цвет вида в активном состоянии
	wchar_t        name[TEXT_LENGTH]; // имя вида
};

#ifdef _UNICODE
#define ViewParamT  ViewParamW
#else
#define ViewParamT  ViewParam
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// Структура параметров слоя
// ---
struct LayerParam {
  unsigned short state;             // состояние слоя
  unsigned long  color;             // цвет слоя в активном состоянии
  char           name[TEXT_LENGTH]; // имя слоя
};

//-------------------------------------------------------------------------------
// Структура параметров слоя ( Unicode )
// ---
struct LayerParamW {
  unsigned short state;            // состояние слоя
  unsigned long  color;            // цвет слоя в активном состоянии
  wchar_t        name[TEXT_LENGTH];// имя слоя
};

#ifdef _UNICODE
#define LayerParamT  LayerParamW
#else
#define LayerParamT  LayerParam
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// Структура параметров запроса к системе :
// Cursor, Placement, CommandWindow
// ---
struct RequestInfo {
  char    * title;      			// строка или идентификатор строки заголовка окна
  char    * commands;   			// строка или идентификатор меню состава команд
  char    * prompt;     			// строка или идентификатор приглашения
  char    * cursor;     			// строка с именем или идентификатор стандартного курсора
  void    * callBack;   			// указатель на функцию обратной связи
  int       dynamic;      		// признак динамического запроса 1-динамический запрос, 0-статический
  HINSTANCE commInstance;     // Instance модуля, в ктором размещен состав команд
};

//-------------------------------------------------------------------------------
// Структура параметров запроса к системе :
// Cursor, Placement, CommandWindow
// (Unicode)
// ---
struct RequestInfoW {
  wchar_t * title;      			// строка или идентификатор строки заголовка окна
  wchar_t * commands;   			// строка или идентификатор меню состава команд
  wchar_t * prompt;     			// строка или идентификатор приглашения
  wchar_t * cursor;     			// строка с именем или идентификатор стандартного курсора
  void    * callBack;   			// указатель на функцию обратной связи
  int       dynamic;      		// признак динамического запроса 1-динамический запрос, 0-статический
  HINSTANCE commInstance;     // Instance модуля, в ктором размещен состав команд
};

#ifdef _UNICODE
#define RequestInfoT  RequestInfoW
#else
#define RequestInfoT  RequestInfo
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// Прототип функции обратной связи для запроса точки и угла.
// Функция возвращает 1, если нужно продолжить запрос,
//                    0, если нужно прекратить запрос.
// ---
typedef int (WINAPI *PlacementCallBack)( int    com,           // идентификатор команды из окна команд
						      double *x, double *y, // координаты точки привязки
						      double *angle,        // угол наклона
						      RequestInfo *info,    // указатель на область памяти для замены состава команд
						      void   *phantom,      // указатель на фантомную группу
                  int    dynamic );     // признак динамического вызова

//-------------------------------------------------------------------------------
// Прототип функции обратной связи для запроса точки и угла. (Unicode)
// Функция возвращает 1, если нужно продолжить запрос,
//                    0, если нужно прекратить запрос.
// ---
typedef int (WINAPI *PlacementCallBackW)( int    com,           // идентификатор команды из окна команд
						      double * x, double * y, // координаты точки привязки
						      double * angle,        // угол наклона
						      RequestInfoW * info,    // указатель на область памяти для замены состава команд
						      void   *phantom,      // указатель на фантомную группу
                  int    dynamic );     // признак динамического вызова

#ifdef _UNICODE
#define PlacementCallBackT  PlacementCallBackW
#else
#define PlacementCallBackT  PlacementCallBack
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// Прототип функции обратной связи для запроса точки.
// Функция возвращает 1, если нужно продолжить запрос,
//                    0, если нужно прекратить запрос.
// ---
typedef int (WINAPI *CursorCallBack)( int     com,             // идентификатор команды из окна команд
		       	 double *x, double *y,    // координаты точки привязки
		       	 RequestInfo *info,       // указатель на область памяти для замены состава команд
	  	     	 void   *phantom,         // указатель на фантомную группу
             int     dynamic );       // признак динамического вызова

//-------------------------------------------------------------------------------
// Прототип функции обратной связи для запроса точки.
// Функция возвращает 1, если нужно продолжить запрос,
//                    0, если нужно прекратить запрос.
// ---
typedef int (WINAPI *CursorCallBackW)( int     com,             // идентификатор команды из окна команд
		       	 double *x, double *y,    // координаты точки привязки
		       	 RequestInfoW *info,       // указатель на область памяти для замены состава команд
	  	     	 void   *phantom,         // указатель на фантомную группу
             int     dynamic );       // признак динамического вызова


#ifdef _UNICODE
#define CursorCallBackT  CursorCallBackW
#else
#define CursorCallBackT  CursorCallBack
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// Прототип функции обратной связи для запроса окна с деревом команд
// Функция возвращает 1, если нужно продолжить запрос,
//                    0, если нужно прекратить запрос.
// ---
typedef int (WINAPI *CommandWindowCallBack)( int com,            // идентификатор команды из окна команд
																			       RequestInfo *info ); // указатель на область памяти для замены состава команд

//-------------------------------------------------------------------------------
// Прототип функции обратной связи для запроса окна с деревом команд
// Функция возвращает 1, если нужно продолжить запрос,
//                    0, если нужно прекратить запрос.
// ---
typedef int (WINAPI *CommandWindowCallBackW)( int com,            // идентификатор команды из окна команд
																			        RequestInfoW *info ); // указатель на область памяти для замены состава команд

#ifdef _UNICODE
#define CommandWindowCallBackT  CommandWindowCallBackW
#else
#define CommandWindowCallBackT  CommandWindowCallBack
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// Прототип функции обратной связи для  функций выбора файлов
// функция возвращает 1, если файл отрисован,
//                    0, если не отрисован
// ---
typedef int (WINAPI *FilePreviewFuncCallBack)( HWND HWindow,  // идентификатор окна просмотра
									  													  char * fileName ); // файл, который нужно показать в окне просмотра

//-------------------------------------------------------------------------------
// Прототип функции обратной связи для  функций выбора файлов
// функция возвращает 1, если файл отрисован,
//                    0, если не отрисован
// ---
typedef int (WINAPI *FilePreviewFuncCallBackW)( HWND HWindow,  // идентификатор окна просмотра
									  													  LPWSTR fileName ); // файл, который нужно показать в окне просмотра

#ifdef _UNICODE
#define FilePreviewFuncCallBackT  FilePreviewFuncCallBackW
#else
#define FilePreviewFuncCallBackT  FilePreviewFuncCallBack
#endif // !UNICODE


// см. <ldefin2d.h> Определения для функций GetObjParam и SetObjParam
// ALLPARAM ...

//-------------------------------------------------------------------------------
// Структура параметров отрезка
// Поле style имеет значения( системные стили ) :
//	1  - основная,
//  2  - тонкая,
//  3  - осевая,
//  4  - штриховая,
//  5  - волнистая линия
//	6  - вспомогательная,
//  7  - утолщенная,
//  8  - штрих-пунктир с 2 точками,
//  9  - штриховая толстая
//  10 -осевая толстая
//  11 -тонкая, включаемая в штриховку
// ---
struct LineSegParam {
	double         x1,y1;       //начальная точка
	double         x2,y2;       //конечная точка
	unsigned short style;       //тип линии
};

//-------------------------------------------------------------------------------
// Структура параметров дуги по углам
// ---
struct ArcParam {
	double         xc,yc;       // центр
	double         rad;         // радиус
	double         ang1;        // начальный угол
	double         ang2;        // конечный угол
	short          dir;         // направление
	unsigned short style;       // тип линии
};

//-------------------------------------------------------------------------------
// Структура параметров дуги по точкам
// ---
struct ArcParam1 {
	double         xc,yc;       // центр
	double         rad;         // радиус
	double         x1,y1;       // начальная точка
	double         x2,y2;       // конечная точка
  short          dir;         // направление
  unsigned short style;       // тип линии
};

//-------------------------------------------------------------------------------
// Структура параметров математической точки
// ---
struct MathPointParam {
	double  x, y;       //координаты точки
};

//-------------------------------------------------------------------------------
// Структура параметров габаритного прямоугольника
// ---
struct RectParam {
  MathPointParam  pBot;  //левая нижняя точка прямоугольника
  MathPointParam  pTop;  //правая верхня точка прямоугольника
};

// Поле style для точки( системные стили ) :
//0 - точка
//1 - крестик
//2 - х-точка
//3	-	квадрат
//4	-	треугольник
//5	-	окружность
//6	-	звезда
//7	-	перечеркнутый квадрат
//8	-	утолщенный плюс

//-------------------------------------------------------------------------------
// Структура параметров  точки
// ---
struct PointParam {
	double  x, y;       //координаты точки
	unsigned short style; //тип точки
};

//-------------------------------------------------------------------------------
// Структура параметров  узла  для  Bezier - кривой
// ---
struct BezierPointParam {
	double  x, y;       //координаты базовой точки
	double  ang;        //угол наклона касательной к кривой в базовой точке
	double  left;       //расстояние от базовой точки к левой точке узла
	double  right;      //расстояние от базовой точки к правой точке узла
};


//-------------------------------------------------------------------------------
// Структура параметров  узла  для  Nurbs - кривой
// ---
struct NurbsPointParam {
	double  x, y;       //координаты базовой точки
	double  weight;     //вес точки должен быть > 0
};

//-------------------------------------------------------------------------------
// Структура параметров  bezier сплайна
// ---
struct BezierParam {
  reference pMathPoint;   // динамический массив математических точек сплайна
	unsigned char closed;   //признак замкнутости сплайна 0-не замкнут 1- замкнут
	unsigned short style;   //тип линии
};

//-------------------------------------------------------------------------------
// Структура параметров окружности
// ---
struct CircleParam {
	double       xc,yc;       //центр
	double       rad;         //радиус
	unsigned short style;     //тип линии
};

//-------------------------------------------------------------------------------
// Структура параметров  вспомогательной линии
// ---
struct LineParam {
	double x, y;    //координаты точки на прямой
	double ang;     //угол прямой к оси X
};

//-------------------------------------------------------------------------------
// Структура параметров  эллипса
// ---
struct EllipseParam {
	double xc, yc;            //координаты центра
  double a, b;              //полуоси эллипса
	double ang;               //угол наклона эллипса к оси X
  unsigned short style;       //тип линии
};

//-------------------------------------------------------------------------------
// структура параметров для построения дуги эллипса
// ---
struct EllipseArcParam {
  double xc; double yc;    //координаты центра
  double a, b;             //полуоси эллипса
	double ang;              //угол наклона эллипса ( оси a ) к оси X
  double angFirst;         //начальный угол дуги к оси a
  double angSecond;        //конечный угол  дуги к оси a 
  short dir;               //направление
  unsigned short style;    //тип линии
};

//-------------------------------------------------------------------------------
// структура параметров для параметрического построения дуги эллипса
// ---
struct EllipseArcParam1 {
  double xc; double yc;    //координаты центра
  double a, b;             //полуоси эллипса
	double ang;              //угол наклона эллипса ( оси a ) к оси X
  double parFirst;         //начальное значение параметра
  double parSecond;        //конечное значение параметра
  short  dir;              //направление
  unsigned short style;    //тип линии
};

//-------------------------------------------------------------------------------
// Структура параметров  эквидистанты
// ---
struct EquidistantParam {
  reference     geoObj;   // геометрический объект -базовая кривая эквидистанты
  unsigned char side;     // признак, с какой стороны строить эквидистанту
                          // 0-слева по направлению, 1-справа по направлению, 2-с двух сторон
  unsigned char cutMode;  // тип обхода углов контура
                          // 0-обход срезом, 1- обход дугой
  unsigned char degState; // флаг разрешения вырожденных сегментов эквидистанты
                          // 0-вырожденные сегменты запрещены, 1-вырожденные сегменты разрешены
  double        radRight; // радиус эквидистанты справа по направлению кривой
  double        radLeft;  // радиус эквидистанты слева
  unsigned short  style;    // тип линии
};


// Поле style для штриховки( системные стили ) :
// 0  - металл
// 1  - неметалл 
// 2  - дерево
// 3  - камень естественный
// 4  - керамика
// 5  - бетон
// 6  - стекло
// 7  - жидкость
// 8  - естественный грунт
// 9  - насыпной грунт
// 10 - камень искусственный
// 11 - железобетон
// 12 - напряженный железобетон
// 13 - дерево в продольном сечении
// 14 - песок

//-------------------------------------------------------------------------------
// Структура параметров  штриховки
// ---
struct HatchParam {
	unsigned short style;   //тип штриховки
	double ang;             //угол штриховки
	double step;            //шаг штриховки
	double width;           //ширина полосы, 0-штриховать сплошь
	double x, y;            //базовая точка (нужна только для отрисовки)
  reference pBoundaries;  //временная группа-границы штриховки; используется для GetObjParam и ksHatch
};

//-------------------------------------------------------------------------------
// Структура параметров  штриховки расширенная
// ---
struct HatchParamEx {
	unsigned short style;   //тип штриховки
	double ang;             //угол штриховки
	double step;            //шаг штриховки
	double width;           //ширина полосы, 0-штриховать сплошь
	double x, y;            //базовая точка (нужна только для отрисовки)
  reference pBoundaries;  //временная группа-границы штриховки; используется для GetObjParam и ksHatch
  unsigned long color;    //цвет, по умолчанию FREE_COLOR (0xff000000l1l)    1
  unsigned char sheetAng; //0 -   угол собственный ( накатка ) 1 -угол листовой ( обычная штриховка)
};


// см. <ldefin2d.h> Определения флагов для текста
// INVARIABLE ...

// см. <ldefin2d.h> CHAR_STR_ARR ... - типы динамических массивов

// Поле style для текста( системные стили ) :
// 0 -умолчательный стиль на данного типа объекта
// 1  обычный текст
// 2  текст для технических требований
// 3  текст размера
// 4  текст шероховатости
// 5  текст для линии выноски  ( позиционной )
// 6  текст для линии выноски  ( над\под полкой )
// 7  текст для линии выноски  ( сбоку )
// 8  текст для допуска формы
// 9  текст для таблицы ( заголовок )
// 10 текст для таблицы ( ячейка )
// 11 текст для линии разреза
// 12 текст для стрелки вида
// 13 текст для шероховатости по умолчанию
// 14 текст для обозначения изменения


//-------------------------------------------------------------------------------
// Структура параметров параграфа
// ---
struct ParagraphParam {
	unsigned short style;  // номер стиля текста, если 0 - умолчательный стиль
	double x, y;           // точка привязки текста
	double ang;            // угол наклона текста
	unsigned int hFormat;  // признак горизонтального форматирования 0- нет форматирования 1-сужение текста 2-перенос на другую строку
	unsigned int vFormat;  // признак вертикального форматирования 0- нет форматирования 1-изменение шага строк
	double width;          // ширина блока форматирования
	double height;         // высота блока форматирования
};


//-------------------------------------------------------------------------------
// Структура параметров текста
// ---
struct TextParam {
	ParagraphParam par;    // параметры параграфа
	reference pTextLine;   // указатель на динамический массив строк текста TEXT_LINE_ARR
};

//-------------------------------------------------------------------------------
// Структура параметров строки текста
// ---
struct TextLineParam {  //параметры строки текта
	unsigned short style; //номер стиля строки текста, если 0 - умолчательный стиль
	reference pTextItem;  //указатель на динамический массив компонент строки текста TEXT_ITEM_ARR
};

//-------------------------------------------------------------------------------
// Структура параметров фонта компоненты строки текста
// ---
struct  TextItemFont {
	char          fontName[MAX_TEXT_LENGTH]; // имя фонта
	double        height;                    // высота текста
	double        ksu;                       // сужение текста
	unsigned long color;                     // цвет
	unsigned int  bitVector;                 // битовый вектор (наклон, толщина, подчеркивание, тип составной части(дробь, отклонение, выражение типа суммы))
};

//-------------------------------------------------------------------------------
// Структура параметров фонта компоненты строки текста ( Unicode )
// ---
struct  TextItemFontW {
	wchar_t       fontName[MAX_TEXT_LENGTH];  // имя фонта
	double        height;                     // высота текста
	double        ksu;                        // сужение текста
	unsigned long color;                      // цвет
	unsigned int  bitVector;                  // битовый вектор (наклон, толщина, подчеркивание, тип составной части(дробь, отклонение, выражение типа суммы))
};

#ifdef _UNICODE
#define TextItemFontT  TextItemFontW
#else
#define TextItemFontT  TextItemFont
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// Структура параметров компоненты строки текста
// ---
struct TextItemParam {
  int          tip;            // tip = SPECIAL_SYMBOL , FONT_SYMBOL, FRACTION_TYPE, SUM_TYPE  или 0
	TextItemFont font;           // параметры фонта для компоненты текста
	char         s[TEXT_LENGTH]; // массив символов  для компоненты текста
  unsigned int iSNumb;         // номер спецсимвола, символа из произвольного фонта или тип отрисовки дроби или выражения типа суммы или  0
};

//-------------------------------------------------------------------------------
// Структура параметров компоненты строки текста (Unicode)
// ---
struct TextItemParamW {
  int           tip;            // tip = SPECIAL_SYMBOL , FONT_SYMBOL, FRACTION_TYPE, SUM_TYPE  или 0
	TextItemFontW font;           // параметры фонта для компоненты текста
	wchar_t       s[TEXT_LENGTH]; // массив символов  для компоненты текста
  unsigned int  iSNumb;         // номер спецсимвола, символа из произвольного фонта или тип отрисовки дроби или выражения типа суммы или  0
};

#ifdef _UNICODE
#define TextItemParamT  TextItemParamW
#else
#define TextItemParamT  TextItemParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// Структура параметров стандартного листа
// ---
struct StandartSheet {
  unsigned char  format;   // формат   0(А0) ... 4(А4)
  unsigned char  multiply; // кратность чертежа
  unsigned char  direct;   // расположение штампа 0 вдоль короткой стороны
};


//-------------------------------------------------------------------------------
// Структура для  получения размеров листа  - для использования в GetObjParam()
// и SetObjParam(); Параметры нестандартного листа
// ---
struct SheetSize {
  double  width;   // длина листа
  double  height;  // высота листа
};



//-------------------------------------------------------------------------------
// Структура параметров оформления
// ---
struct SheetPar{
  char         layoutName[MAX_TEXT_LENGTH];// для чертежа -имя  библиотеки оформления( штампа); пустая строка - GRAPHIC.LYT
                                           // для спецификации - имя библиотеки стилей спецификации  пустая строка - GRAPHIC.LYT
  unsigned int shtType;                    // для чертежа- тип штампа (1-13- стандартные штампы)
                                           // для спецификации - номер стиля спецификации
  union {//только для чертежей
    struct StandartSheet stPar;  //параметры
    struct SheetSize     usPar;
  };
};

//-------------------------------------------------------------------------------
// Структура параметров оформления ( Unicode )
// ---
struct SheetParW{
  wchar_t      layoutName[MAX_TEXT_LENGTH];// для чертежа -имя  библиотеки оформления( штампа); пустая строка - GRAPHIC.LYT
                                           // для спецификации - имя библиотеки стилей спецификации  пустая строка - GRAPHIC.LYT
  unsigned int shtType;                    // для чертежа- тип штампа (1-13- стандартные штампы)
                                           // для спецификации - номер стиля спецификации
  union {//только для чертежей
    struct StandartSheet stPar;  //параметры
    struct SheetSize     usPar;
  };
};

#ifdef _UNICODE
#define SheetParT  SheetParW
#else
#define SheetParT  SheetPar
#endif // !UNICODE


//-------------------------------------------------------------------------------
// Структура параметров оформления
// ---
struct SheetOptions{
  SheetPar      sheetPar;  // Структура параметров оформления (старое API)
  unsigned char docType;   // Тип документа из DocType
};

//-------------------------------------------------------------------------------
// Структура параметров оформления
// (Unicode)
// ---
struct SheetOptionsW{
  SheetParW     sheetPar;  // Структура параметров оформления (старое API)
  unsigned char docType;   // Тип документа из DocType
};

#ifdef _UNICODE
#define SheetOptionsT  SheetOptionsW
#else
#define SheetOptionsT  SheetOptions
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// Структура параметров перекрывающихся объектов
// ---
struct OverlapObjectOptions{
  unsigned short overlap; // 1 - перекравать штриховки и линии при пересечении, если 0 - не перекравать
  double gap;             // Зазор при перекрывании объектов
};


//-------------------------------------------------------------------------------
// см. <ldefin2d.h> DocType - типы документов
// Структура параметров документа ( под документом понимается лист и фрагмент, спецификация )
// ---
struct DocumentParam {
  unsigned char regim;                     // 0 - видимый режим,
                                           // 1 - невидимый режим
  unsigned char type;                      // тип документа из DocType

  char          fileName [MAX_TEXT_LENGTH];// имя  файла чертежа
  char          comment  [TEXT_LENGTH];    // комментарий
  char          author   [TEXT_LENGTH];    // автор
  SheetPar      sheet;                     // используется для чертежей type = 1, 2, 4;
};


//-------------------------------------------------------------------------------
// см. <ldefin2d.h> DocType - типы документов  ( Unicode )
// Структура параметров документа ( под документом понимается лист и фрагмент, спецификация )
// ---
struct DocumentParamW {
  unsigned char regim;                     // 0 - видимый режим,
                                           // 1 - невидимый режим
  unsigned char type;                      // тип документа из DocType

  wchar_t       fileName [MAX_TEXT_LENGTH];// имя  файла чертежа
  wchar_t       comment  [TEXT_LENGTH];    // комментарий
  wchar_t       author   [TEXT_LENGTH];    // автор
  SheetParW     sheet;                     // используется для чертежей type = 1, 2, 4;
};

#ifdef _UNICODE
#define DocumentParamT  DocumentParamW
#else
#define DocumentParamT  DocumentParam
#endif // !UNICODE

/***************************************************************/
/* Структуры для работы с табличными атрибутами  */
/***************************************************************/
//-------------------------------------------------------------------------------
// см. <ldefin2d.h> CHAR_ATTR_TYPE ...
// Информационная структура для одного столбца табличного атрибута
// ---
struct ColumnInfo {
  char          header[80];       // заголовoк-комментарий столбца
  unsigned char type;             // тип данных в столбце - см.ниже
  unsigned char key;              // дополнительный признак, который позволит отличить две переменные с одинаковым типом
  char          def[TEXT_LENGTH]; // значение по умолчанию
  unsigned char flagEnum;         // флаг включающий режим, когда значение поля атрибута
                                  // будет заполнятся из массива перечисленных значений 1 и 0 отключон
  reference fieldEnum;            // массив неопределенной длины перечислений (строки)
  reference columns;              // массив неопределенной длины информации о колонках для записи
};

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> CHAR_ATTR_TYPE ...
// Информационная структура для одного столбца табличного атрибута
// (Unicode)
// ---
struct ColumnInfoW {
  wchar_t       header[80];       // заголовoк-комментарий столбца
  unsigned char type;             // тип данных в столбце - см.ниже
  unsigned char key;              // дополнительный признак, который позволит отличить две переменные с одинаковым типом
  wchar_t       def[TEXT_LENGTH]; // значение по умолчанию
  unsigned char flagEnum;         // флаг включающий режим, когда значение поля атрибута
                                  // будет заполнятся из массива перечисленных значений 1 и 0 отключон
  reference fieldEnum;            // массив неопределенной длины перечислений (строки)
  reference columns;              // массив неопределенной длины информации о колонках для записи
};

#ifdef _UNICODE
#define ColumnInfoT  ColumnInfoW
#else
#define ColumnInfoT  ColumnInfo
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// Структура типа табличного атрибута
// ---
struct AttributeType {        // 26.6.97 устаревшая структура со временем будет убрана
  char          header[80];   // заголовoк-комментарий типа
  unsigned int  rowsCount;    // кол-во строк в таблице
  unsigned char flagVisible;  // видимый, невидимый   в таблице
  char          password[10]; // пароль, если не пустая строка  - защищает от несанкционированного изменения типа
  reference     columns;      // массив неопределенной длины информации о колонках
};


//-------------------------------------------------------------------------------
// Структура типа табличного атрибута
// ---
struct ksAttributeType {
  unsigned int  key1;         // рекоменд. как код разработчика
  unsigned int  key2;         // рекоменд. как код атрибута
  unsigned int  key3;         // рекоменд. как код разработчика
  unsigned int  key4;         // системный код атрибута
                              // значения от 0 до 1000 зарезервированы
                              // за АО "АСКОН"
  char          header[80];   // заголовoк-комментарий типа
  unsigned int  rowsCount;    // кол-во строк в таблице
  unsigned char flagVisible;  // видимый, невидимый   в таблице
  char          password[10]; // пароль, если не пустая строка  - защищает от несанкционированного изменения типа
  reference     columns;      // массив неопределенной длины информации о колонках
};

//-------------------------------------------------------------------------------
// Структура типа табличного атрибута
// (Unicode)
// ---
struct ksAttributeTypeW {
  unsigned int  key1;         // рекоменд. как код разработчика
  unsigned int  key2;         // рекоменд. как код атрибута
  unsigned int  key3;         // рекоменд. как код разработчика
  unsigned int  key4;         // системный код атрибута
                              // значения от 0 до 1000 зарезервированы
                              // за АО "АСКОН"
  wchar_t       header[80];   // заголовoк-комментарий типа
  unsigned int  rowsCount;    // кол-во строк в таблице
  unsigned char flagVisible;  // видимый, невидимый   в таблице
  wchar_t       password[10]; // пароль, если не пустая строка  - защищает от несанкционированного изменения типа
  reference     columns;      // массив неопределенной длины информации о колонках
};

#ifdef _UNICODE
#define ksAttributeTypeT  ksAttributeTypeW
#else
#define ksAttributeTypeT  ksAttributeType
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// Структура  табличного атрибута
// ---
struct Attribute { // 05.6.00 устаревшая структура со временем будет убрана
  unsigned int    key1;         // рекоменд. как код разработчика
  unsigned int    key2;         // рекоменд. как код атрибута
  unsigned int    key3;         // рекоменд. как код разработчика
  unsigned int    key4;         // системный код атрибута
                                // значения от 0 до 1000 зарезервированы
                                // за АО "АСКОН"
  unsigned char * flagVisible;  // массив, определяющий для каждой колонки
                                // атрибута видимость-невидимость
                                // 0 -видимое поле 1- невидимое поле
  void          * values;       // массив значений ячеек таблицы атрибутов
                                // сначала все значения для 1-ой строки,
                                // затем все значения для 2-ой строки и т.д.
  unsigned int    valSize;      // размер массива значений ячеек
  char            password[10]; // пароль, если не пустая строка  - защищает от несанкционированного изменения информации в атрибуте
};

//-------------------------------------------------------------------------------
// Структура  табличного атрибута
// ---
struct ksAttribute {
  unsigned int    key1;         // рекоменд. как код разработчика
  unsigned int    key2;         // рекоменд. как код атрибута
  unsigned int    key3;         // рекоменд. как код разработчика
  unsigned int    key4;         // системный код атрибута
                                // значения от 0 до 1000 зарезервированы
                                // за АО "АСКОН"
  unsigned char * flagVisible;  // массив, определяющий для каждой колонки
                                // атрибута видимость-невидимость
                                // 0 -видимое поле 1- невидимое поле
  void          * values;       // массив значений ячеек таблицы атрибутов
                                // сначала все значения для 1-ой строки,
                                // затем все значения для 2-ой строки и т.д.
  unsigned int    valSize;      // размер массива значений ячеек
  char            password[10]; // пароль, если не пустая строка  - защищает от несанкционированного изменения информации в атрибуте
  unsigned char * columnKeys;   // массив ключей колонок
};

//-------------------------------------------------------------------------------
// Структура  табличного атрибута
// (Unicode)
// ---
struct ksAttributeW {
  unsigned int    key1;         // рекоменд. как код разработчика
  unsigned int    key2;         // рекоменд. как код атрибута
  unsigned int    key3;         // рекоменд. как код разработчика
  unsigned int    key4;         // системный код атрибута
                                // значения от 0 до 1000 зарезервированы
                                // за АО "АСКОН"
  unsigned char * flagVisible;  // массив, определяющий для каждой колонки
                                // атрибута видимость-невидимость
                                // 0 -видимое поле 1- невидимое поле
  void          * values;       // массив значений ячеек таблицы атрибутов
                                // сначала все значения для 1-ой строки,
                                // затем все значения для 2-ой строки и т.д.
  unsigned int    valSize;      // размер массива значений ячеек
  wchar_t         password[10]; // пароль, если не пустая строка  - защищает от несанкционированного изменения информации в атрибуте
  unsigned char * columnKeys;   // массив ключей колонок
};

#ifdef _UNICODE
#define ksAttributeT  ksAttributeW
#else
#define ksAttributeT  ksAttribute
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// структура параметров для типа атрибута библиотеке типов атрибутов
// ---
struct LibraryAttrTypeParam {
  char     name [MAX_TEXT_LENGTH];// имя  типа атрибута
  double   typeId;                // номер типа атрибута в библиотеке
};

//-------------------------------------------------------------------------------
// структура параметров для типа атрибута библиотеке типов атрибутов
// (Unicode)
// ---
struct LibraryAttrTypeParamW {
  wchar_t  name [MAX_TEXT_LENGTH];// имя  типа атрибута
  double   typeId;                // номер типа атрибута в библиотеке
};

#ifdef _UNICODE
#define LibraryAttrTypeParamT  LibraryAttrTypeParamW
#else
#define LibraryAttrTypeParamT  LibraryAttrTypeParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
//
// ---
struct  CON {
  double xc, yc;                  // центр сопрягающей окружности
  double x1, y1, x2, y2;          // координаты точки сопряжения
};

//-------------------------------------------------------------------------------
//
// ---
struct  TAN {
  double x1, y1, x2, y2;          //координаты точек касания
};

//Функция удаления элемента пользовательского динамического массива
typedef void ( WINAPI *DeleteFunc)(void * );


//-------------------------------------------------------------------------------
// см. <ldefin2d.h> Определения для линейного размера
// _AUTONOMINAL ...
// Структура параметров размерной надписи
// ---
struct DimText {  //структура размерной надписи
  unsigned short style; // стиль текста размера, если 0 -умолчательный стиль
  unsigned int sign;    // номер условного значка перед номиналом 0-ничего 1 - диаметр, 2- квадрат 3- радиус  > 3 - номер из фонта "Symbol type A"
  unsigned int bitFlag; // 0 - ручное задание или набор битовых полей
  reference  pText;     // динамический массив строк  (DIM_TEXT_PARAM) или массив расширенных строк (DIM_TEXT_PARAM_W)
                        // строки должны лежать в последовательности с учетом включения
                        // битовых флагов:  PREFIX, номинал, TOLERANCE,
                        // верхнее отклонение, нижнее отклонение, UNIT,SUFFIX,
                        // верхнее отклонение, нижнее отклонение принимаются, если
                        // флаг TOLERANCE не включен а DEVIATION включен - признак
                        // ручной простановки отклонений
                        // другие строки
   unsigned char stringFlag;// 0- pText   - динамический массив  строк символов (DIM_TEXT_PARAM) или массив  строк расширенных символов (DIM_TEXT_PARAM_W)
                            // 1- pText  TEXT_LINE_ARR - динамический массив  строк текста- структура TextLineParam
                            // для функции GetObjParam нужно определить этот флаг, если 0 - выдается динамический массив  строк символов
};


//-------------------------------------------------------------------------------
// Структура параметров привязки линейного  размера
// ---
struct LDimSource {
  unsigned char ps;        // признак 0-горизонтальный, 1-вертикальный 2 - паралл.отрезку, 3 - по dx,dy, 4- параллельно отрезку с выносными линиями по dx, dy
  double x1, y1;           // координаты   1 -ой точки привязки
  double x2, y2;           // координаты   2 -ой точки привязки
  double dx, dy;           // вектор определяющий положение размерной линии; аннотационный ( не зависит от масштаба )
  unsigned char basePoint; // признак 1-dx, dy -откладвать от первой точки, 2- от второй
};

//-------------------------------------------------------------------------------
// Структура параметров отрисовки линейного и углового размеров
// ---
struct DimDrawing {
  unsigned char pl1;      // признак вкл./выкл.  отрисовки 1 выносной линии  0/1
  unsigned char pl2;      // признак вкл./выкл.  отрисовки 2 выносной линии  0/1

// тип стрелки у 1-ой выносной линии
// 0 - стрелки нет 1 - изнутри(ласточкин хвост) 2 - снаружи(ласточкин хвост) 3 - засечка 4 - вспомогательная точка
// 5 - стрелка закрытая изнутри 6 - стрелка закрытая снаружи 7 - стрелка открытая изнутри 8 - стрелка открытая снаружи
// 9 - стрелка 90 град изнутри 10 - стрелка 90 град снаружи 11 - точка ( диаметр равен длине стрелки размера )
// 12 - точка маленькая ( диаметр равен 0.6 длины стрелки размера )
// 13 - засечка с наклоном влево
  unsigned char pt1;
  unsigned char pt2;      // тип стрелки у 2-ой выносной линии
  int textPos;            // положение текста; 0- обозначает автоматическое размещение текста
                          // мм - лин. р. град.- угл. размер; >0 в направлении от 1 точки ко 2;  аннотационный ( не зависит от масштаба )
  unsigned char textBase; // параметр отрисовки текста: 0 в центре,  1- textPos относительно 1 точки;
                          // 2 - textPos относительно 2 точки; 3- общая размерная линия
  int shelfDir;           // наличие выносной полки направление по оси X   0-нет выносной полки -1-направлена влево 1-направлена вправо
                          // 2- полка направлена в вверх 3- полка направлена вниз
  double ang;             // угол наклона ножки
  int length;             // длина ножки; аннотационная ( не зависит от масштаба )
};

//-------------------------------------------------------------------------------
// Структура параметров линейного размера
// ---
struct LDimParam {
  DimText    tPar;  // размерная надпись                      3
  DimDrawing dPar;  // параметры изображения размера          2
  LDimSource sPar;  // параметры привязки линейного размера   1
};


//-------------------------------------------------------------------------------
// Структура параметров привязки линейного  размера с обрывом
// ---
struct LBreakDimSource {
  double x1, y1;           // координаты   1 -ой точки привязки
  double x2, y2;           // координаты   выхода стрелки
  double x3, y3;           // координаты   точки на размерной линии
};

//-------------------------------------------------------------------------------
// Структура параметров отрисовки линейного и углового размера с обрывом
// ---
struct BreakDimDrawing {
  unsigned char pl;      // признак вкл./выкл.  отрисовки  выносной линии  0/1

// тип стрелки у 1-ой выносной линии
// 0 - стрелки нет 1 - изнутри(ласточкин хвост) 2 - снаружи(ласточкин хвост) 3 - засечка 4 - вспомогательная точка
// 5 - стрелка закрытая изнутри 6 - стрелка закрытая снаружи 7 - стрелка открытая изнутри 8 - стрелка открытая снаружи
// 9 - стрелка 90 град изнутри 10 - стрелка 90 град снаружи 11 - точка ( диаметр равен длине стрелки размера )
// 12 - точка маленькая ( диаметр равен 0.6 длины стрелки размера )
// 13 - засечка с наклоном влево

  unsigned char pt;
  int textPos;           // положение текста; 0- обозначает автоматическое размещение текста
                         // мм - лин. р. ; >0 в направлении от 1 точки ко 2;  аннотационный ( не зависит от масштаба )
  int shelfDir;          // наличие выносной полки направление по оси X   0-нет выносной полки -1-направлена влево 1-направлена вправо
                         // 2- полка направлена в вверх 3- полка направлена вниз
  double ang;            // угол наклона ножки
  int length;            // длина ножки; аннотационная ( не зависит от масштаба )
};

//-------------------------------------------------------------------------------
// Структура параметров линейного размера c обрывом
// ---
struct LBreakDimParam {
  DimText          tPar;  // размерная надпись                      3
  BreakDimDrawing  dPar;  // параметры изображения размера          2
  LBreakDimSource  sPar;  // параметры привязки линейного размера   1
};

//-------------------------------------------------------------------------------
// Структура параметров привязки углового размера
// ---
struct ADimSource {
  double xc, yc;       // центр размерной дуги
  double rad;          // радиус размерной дуги;  аннотационный ( не зависит от масштаба )
	double ang1;         // начальный угол  размерной дуги
	double ang2;         // конечный угол  размерной дуги, для размера с обрывом угол симметричного отрезка
  int    dir;          // направление 1 - размерная линия против часовой стрелки; -1 - по часовой стрелке
  double x1, y1;       // точка выхода первой выносной линии
  double x2, y2;       // точка выхода второй выносной линии, для размера с обрывом точка на оси симметрии
};

//-------------------------------------------------------------------------------
// Структура параметров углового размера
// ---
struct ADimParam {
  DimText    tPar;  // размерная надпись                      3
  DimDrawing dPar;  // параметры изображения размера          2
  ADimSource sPar;  // параметры привязки углового размера    1
};

//-------------------------------------------------------------------------------
// Структура параметров углового размера c обрывом
// ---
struct ABreakDimParam {
  DimText          tPar;  // размерная надпись                      3
  BreakDimDrawing  dPar;  // параметры изображения размера          2
  ADimSource       sPar;  // параметры привязки линейного размера   1
};

//-------------------------------------------------------------------------------
// структура параметров привязки диаметрального и радиального размеров
// ---
struct RDimSource {
  double xc, yc;       // координаты центра дуги , окружности
  double rad;          // радиус дуги , окружности
};

//-------------------------------------------------------------------------------
// структура параметров отрисовки  диаметрального и радиального размеров
// ---
struct RDimDrawing {
// тип стрелки у 1-ой выносной линии
// 0 - стрелки нет 1 - изнутри(ласточкин хвост) 2 - снаружи(ласточкин хвост) 3 - засечка 4 - вспомогательная точка
// 5 - стрелка закрытая изнутри 6 - стрелка закрытая снаружи 7 - стрелка открытая изнутри 8 - стрелка открытая снаружи
// 9 - стрелка 90 град изнутри 10 - стрелка 90 град снаружи 11 - точка ( диаметр равен длине стрелки размера )
// 12 - точка маленькая ( диаметр равен 0.6 длины стрелки размера )
// 0xff - размер с обрывом(для диаметрального)
  unsigned char pt1;
  unsigned char pt2;      // (диам размер)тип 2-ой стрелки,( рад размер) 0 - размер от центра 1- не от центра
  int           textPos;  // параметр отрисовки текста или длина ножки; аннотационный ( не зависит от масштаба )
                          // 0 - автоматическое размещение в центре,
                          // 1 - автоматическое размещение за дугой по направлению угла,
                          // -1- автоматическое размещение за дугой против направления угла
                          // откладывается от центра дуги
  int           shelfDir; // наличие выносной полки направление по оси X   0-нет выносной полки -1-направлена влево 1-направлена вправо
                          // 2- полка направлена в вверх 3- полка направлена вниз
  double        ang;      // угол наклона размерной линии и ножки
};

//-------------------------------------------------------------------------------
// структура параметров  диаметрального  и  обычного радиального размера
// ---
struct RDimParam {
  DimText     tPar;    // размерная надпись                                        3
  RDimDrawing dPar;    // параметры изображения размера                            2
  RDimSource  sPar;    // параметры привязки диаметрального и радиального размеров 1
};

//-------------------------------------------------------------------------------
// структура параметров отрисовки радиального размера с изломом
// ---
struct RBreakDrawing {
// тип стрелки у 1-ой выносной линии
// 0 - стрелки нет 1 - изнутри(ласточкин хвост) 2 - снаружи(ласточкин хвост) 3 - засечка 4 - вспомогательная точка
// 5 - стрелка закрытая изнутри 6 - стрелка закрытая снаружи 7 - стрелка открытая изнутри 8 - стрелка открытая снаружи
// 9 - стрелка 90 град изнутри 10 - стрелка 90 град снаружи 11 - точка ( диаметр равен длине стрелки размера )
// 12 - точка маленькая ( диаметр равен 0.6 длины стрелки размера )
  unsigned char pt;
  double ang;       // угол наклона размерной линии
  unsigned int  pb; // длина излома; аннотационный ( не зависит от масштаба )
};

//-------------------------------------------------------------------------------
// структура параметров  радиального размера с изломом
// ---
struct RBreakDimParam {
  RDimSource    sPar; // параметры привязки углового размера    1
  RBreakDrawing dPar; // параметры изображения размера          2
  DimText       tPar; // размерная надпись                      3
};


// типы размеров высоты
#define OD_FRONTVIEW     0x00 // для вида спереди, с полкой и стрелкой, возможна выносная линия
#define OD_TOPVIEW       0x08 // для вида сверху без линии-выноски - только текст в рамке
#define OD_TOPVIEWLEADER 0x10 // для вида сверху с линией-выноской

// параметры изображения размера высоты
struct OrdinatedDrawing {
  unsigned char type; // тип размера высоты
};

//-------------------------------------------------------------------------------
// параметры привязки размера высоты
// ---
struct OrdinatedSource {
  double x0, y0;           // координаты точки, задающей нулевой уровень
  double x1, y1;           // координаты точки, задающей измеряемый уровень
  double x2, y2;           // координата точки, задающей положение размерной надписи
};


//-------------------------------------------------------------------------------
// Структура параметров размера высоты ORDINATEDIMENSION_OBJ
// ---
struct OrdinatedDimParam {
  DimText          tPar;  // размерная надпись
  OrdinatedDrawing dPar;  // параметры изображения размера
  OrdinatedSource  sPar;  // параметры привязки размера
};


//#define   INDICATIN_TEXT_LINE_ARR        0xFFFF  //для шероховаиости, позиционной линии выноски, маркировки и клеймения
                                                 //признак, что для текста используется динамический массив TEXT_LINE_ARR

//-------------------------------------------------------------------------------
// структура параметров   шероховатости
// ---
struct RoughPar {
  unsigned short style; // стиль текста, если 0 - умолчательный стиль,
                        // если style = INDICATIN_TEXT_LINE_ARR -> pText- массив TEXT_LINE_ARR
  unsigned char type;   // тип шероховатости  0-вид обр-ки не уст-ся 1- обр-ка удалением слоя материала
                        // 2 -обр-ка без удаления слоя материала
  unsigned char around; // =1 - шероховатость "по контуру"
  double x, y;          // координаты точки привязки
  double ang;           // угол наклона оси значка шероховатости с осью X
  unsigned char cText0; // количество строк в тексте над знаком (параметры шер-ти по ГОСТ 2789-73)
  unsigned char cText1; // количество строк в тексте над полкой (вид обр-ки и доп,указания)
  unsigned char cText2; // количество строк в тексте под полкой (базовая длина по ГОСТ 2789-73)
                        // не более 2 строк
  unsigned char cText3; // количество строк в тексте под полкой (усл.обозн.направления неровностей)
                        // не более 1 строк
  reference pText;      // если style = INDICATIN_TEXT_LINE_ARR , TEXT_LINE_ARR - динамический массив строк текста
                        // CHAR_STR_ARR или CHAR_STR_ARR_W - динамический массив строк символов текста шероховатости
                        // различают 4 разных текста для шероховатости;
                        // строки текстов лежат в следующей последовательности
                        // -текст над знаком (параметры шер-ти по ГОСТ 2789-73) - cText0=0 - текст отсутствует
                        // -текст над полкой (вид обр-ки и доп,указания)        - cText1=0 - текст отсутствует
                        // -текст под полкой (базовая длина по ГОСТ 2789-73)    - cText2=0 - текст отсутствует
                        // -текст под полкой (усл.обозн.направления неровностей)- cText3=0 - текст отсутствует
};

//-------------------------------------------------------------------------------
// Структура параметров выносной полки
// ---
struct ShelfPar { // структура  выносной полки
  int psh;        // направление по оси X   0-нет выносной полки -1-направлена влево 1-направлена вправо
                  // 2- полка направлена в вверх 3- полка направлена вниз
  double ang;     // угол наклона ножки  для диаметрального и радиального размеров
                  // это и угол наклона  размерной линии
  int length;     // длина ножки
};

//-------------------------------------------------------------------------------
// Структура параметров шероховатости
// ---
struct RoughParam {
  RoughPar rPar;
  ShelfPar shPar; // параметры выносной полки
};

//-------------------------------------------------------------------------------
// структура параметров для простой линии выноски
// ---
struct LeaderParam {
  double x, y;             // координаты базовой точки ( начало полки )
  // тип стрелки 0 - нет ничего 1 - точка 2 - стрелка 3 - верхняя половина стрелки 4 - нижняя половина стрелки
  //             5 - стрелка угол 90град 6 - стрелка закрытая 7 - стрелка открытая 8 - точка (диаметр равен длины стрелки лини выноски)
  //             9 - точка маленькая (диаметр = 0.6 длины стрелки линии выноски) 10 - треугольник с углом 60град 11 - треугольник с углом 90град
  unsigned char arrowType; 
  int           dirX;      // направление полки по X (1 -вправо -1-влево, 2- полка направлена в вверх 3- полка направлена вниз)
  unsigned char signType;  // тип знака 0- ничего 1-знак склеивания 2-знак пайки
                           // 3- знак сшивания 4 -знак соединения внахлестку металл.скобами
                           // 5 - знак углового соединения металл.скобами
                           // 6 - знак монтажного шва
  unsigned char around;    // знак обработки по контуру 0-выключен 1- включен
  unsigned char cText0;    // количество строк текста над полкой 0- текст отсутствует
  unsigned char cText1;    // количество строк текста под полкой 0- текст отсутствует
  unsigned char cText2;    // количество строк текста над ножкой (не более 1 строки)0- текст отсутствует
  unsigned char cText3;    // количество строк текста под ножкой (не более 1 строки)0- текст отсутствует
  reference pTextline;     // TEXT_LINE_ARR - динамический массив строк текста
                           // различают 4 разных текста для линии выноски
                           // строки текстов лежат в следующей последовательности
                           // -текст над полкой  - cText0=0 - текст отсутствует
                           // -текст под полкой  - cText1=0 - текст отсутствует
                           // -текст над ножкой  - cText2=0 - текст отсутствует
                           // -текст под ножкой  - cText3=0 - текст отсутствует
  reference pPolyline;     // POLYLINE_ARR - динамический массив ответвлений линии выноски
                           // в общем случае одно ответвление - это полилиния
                           // первый узел базовая точка ( ее в массив помещать не нужно - общая для всех ответвлений),
                           // остальные узлы - изломы( могут отсутствовать)
                           // последний узел - конец ответвления (указывает на объект)
};

//-------------------------------------------------------------------------------
// структура параметров линии выноски для обозначения позиции
// ---
struct PosLeaderParam {
  unsigned short style;    // стиль текста, если 0 - умолчательный стиль,
                           // если style = INDICATIN_TEXT_LINE_ARR -> pText- массив TEXT_LINE_ARR
  double x, y;             // координаты базовой точки ( начало првой полки )
  // тип стрелки 0 - нет ничего 1 - точка 2 - стрелка
  //             3 - стрелка угол 90град 4 - стрелка закрытая 5 - стрелка открытая 
  //             6 - точка (диаметр равен длины стрелки лини выноски)
  //             7 - точка маленькая (диаметр = 0.6 длины стрелки линии выноски)
  unsigned char arrowType; //
  int           dirX;      // направление полки по X (1 -вправо -1-влево)
  int           dirY;      // направление построения полок по Y (1 -вверх -1-вниз)
  reference pText;         // если style = INDICATIN_TEXT_LINE_ARR , TEXT_LINE_ARR - динамический массив строк текста
                           // CHAR_STR_ARR или CHAR_STR_ARR_W - динамический массив строк символов
                           // в каждой строке лежит одна позиция
  reference pPolyline;     // POLYLINE_ARR - массив неопределенной длины ответвлений линии выноски
                           // в общем случае одно ответвление - это полиллиния
                           // первый узел базовая точка ( ее в массив помещать не нужно - общая для всех ответвлений),
                           // остальные узлы - изломы( могут отсутствовать)
                           // последний узел - конец ответвления (указывает на объект)
};

//-------------------------------------------------------------------------------
// структура параметров линии выноски для обозначения клеймения
// ---
struct BrandLeaderParam {
  int           dirX;      // направление полки по X (1 -вправо -1-влево)
  double x, y;             // координаты базовой точки ( начало првой полки )
  unsigned char arrowType; // тип стрелки
  unsigned short style1;   // стиль  для текста над полкой, если 0 - умолчательный стиль
                           // если style1 = INDICATIN_TEXT_LINE_ARR -> pText- массив TEXT_LINE_ARR
  unsigned short style2;   // стиль  для текстов у ножки, если 0 - умолчательный стиль
  unsigned char cText0;    // количество строк текста в знаке (не более 1 строки)0- текст отсутствует
  unsigned char cText1;    // количество строк текста над ножкой (не более 1 строки)0- текст отсутствует
  unsigned char cText2;    // количество строк текста под ножкой (не более 1 строки)0- текст отсутствует
  reference pText;         // если style1 = INDICATIN_TEXT_LINE_ARR , TEXT_LINE_ARR - динамический массив строк текста
                           // CHAR_STR_ARR или CHAR_STR_ARR_W - динамический массив строк символов
                           // строки текстов лежат в следующей последовательности
                           // текст над полкой
                           // текста над ножкой
                           // текст под ножкой
  reference pPolyline;     // POLYLINE_ARR - массив неопределенной длины ответвлений линии выноски
                           // в общем случае одно ответвление - это полиллиния
                           // первый узел базовая точка ( ее в массив помещать не нужно - общая для всех ответвлений),
                           // остальные узлы - изломы( могут отсутствовать)
                           // последний узел - конец ответвления (указывает на объект)
};

//-------------------------------------------------------------------------------
// структура параметров линии выноски для обозначения маркирования
// ---
struct MarkerLeaderParam {
  double x, y;             // координаты базовой точки ( начало првой полки )
  unsigned char arrowType; // тип стрелки
  unsigned short style1;   // стиль  для текста над полкой, если 0 - умолчательный стиль
                           // если style1 = INDICATIN_TEXT_LINE_ARR -> pText- массив TEXT_LINE_ARR
  unsigned short style2;   // стиль  для текстов у ножки, если 0 - умолчательный стиль
  unsigned char cText0;    // количество строк текста в знаке(не более 1 строки)0- текст отсутствует
  unsigned char cText1;    // количество строк текста над ножкой (не более 1 строки)0- текст отсутствует
  unsigned char cText2;    // количество строк текста под ножкой (не более 1 строки)0- текст отсутствует
  reference pText;         // если style1 = INDICATIN_TEXT_LINE_ARR , TEXT_LINE_ARR - динамический массив строк текста
                           // CHAR_STR_ARR или CHAR_STR_ARR_W - динамический массив строк символов
                           // строки текстов лежат в следующей последовательности
                           // текст над полкой
                           // текста над ножкой
                           // текст под ножкой
  reference pPolyline;     // POLYLINE_ARR - массив неопределенной длины ответвлений линии выноски
                           // в общем случае одно ответвление - это полиллиния
                           // первый узел базовая точка ( ее в массив помещать не нужно - общая для всех ответвлений),
                           // остальные узлы - изломы( могут отсутствовать)
                           // последний узел - конец ответвления (указывает на объект)
};


//-------------------------------------------------------------------------------
// структура параметров линии выноски для обозначения маркирования
// ---
struct ChangeLeaderParam {
  double         x, y;         // координаты базовой точки ( начало првой полки )
  unsigned short style;        // стиль  для текста
  unsigned char  signType;     // Тип значка
  double         signHeight;   // Высота значка
  double         leaderLength; // Длина выноски < 0 на всю длину
  reference      pText;        // если style1 = INDICATIN_TEXT_LINE_ARR , TEXT_LINE_ARR - динамический массив строк текста
                               // CHAR_STR_ARR или CHAR_STR_ARR_W - динамический массив строк символов
                               // строки текстов лежат в следующей последовательности
                               // текст над полкой
                               // текста над ножкой
                               // текст под ножкой
  reference     pPolyline;     // POLYLINE_ARR - массив неопределенной длины ответвлений линии выноски
                               // в общем случае одно ответвление - это полиллиния
                               // первый узел базовая точка ( ее в массив помещать не нужно - общая для всех ответвлений),
                               // остальные узлы - изломы( могут отсутствовать)
                               // последний узел - конец ответвления (указывает на объект)
};


//-------------------------------------------------------------------------------
// структура параметров "обозначение базы"
// ---
struct BaseParam {
  unsigned short style;      // стиль текста, если 0 - умолчательный стиль
  double         x1, y1;     // координаты базовой точки ( начало ножки )
  double         x2, y2;     // координаты конечной точки ножки
  unsigned char  type;       // 0- текст в виде строки 1- динамический массив компонент текстов
  union {
    char      str[50];       // надпись
    reference pTextItem;     // динамический массив компонент текта TEXT_ITEM_ARR  (надпись)
  };
};

//-------------------------------------------------------------------------------
// структура параметров "обозначение базы"
// (Unicode)
// ---
struct BaseParamW {
  unsigned short style;  // стиль текста, если 0 - умолчательный стиль
  double         x1, y1; // координаты базовой точки ( начало ножки )
  double         x2, y2; // координаты конечной точки ножки
  unsigned char  type;   // 0- текст в виде строки 1- динамический массив компонент текстов
  union {
    wchar_t   str[50];   // надпись
    reference pTextItem; // динамический массив компонент текта TEXT_ITEM_ARR  (надпись)
  };
};

#ifdef _UNICODE
#define BaseParamT  BaseParamW
#else
#define BaseParamT  BaseParam
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// структура параметров "линии разреза/сечения "
// ---
struct CutLineParam {
  unsigned short style;      // стиль текста, если 0 - умолчательный стиль
  unsigned char  right;      // признак стрелок 0 слева/ 1 справа по направлению ломаной
  double         x1, y1;     // координаты надписи у первого участка
  double         x2, y2;     // координаты надписи у второго участка
  unsigned char  type;       // 0- текст в виде строки 1- динамический массив компонент текстов
  union {
    char      str[50];       // надпись
    reference pTextItem;     // динамический массив компонент текта TEXT_ITEM_ARR  (надпись)
  };
  reference      pMathPoint; // POINT_ARR динамический массив  нач.точка, точки перегибов, кон.точка
};

//-------------------------------------------------------------------------------
// структура параметров "линии разреза/сечения "
// (Unicode)
// ---
struct CutLineParamW {
  unsigned short style;      // стиль текста, если 0 - умолчательный стиль
  unsigned char  right;      // признак стрелок 0 слева/ 1 справа по направлению ломаной
  double         x1, y1;     // координаты надписи у первого участка
  double         x2, y2;     // координаты надписи у второго участка
  unsigned char  type;       // 0- текст в виде строки 1- динамический массив компонент текстов
  union {
    wchar_t   str[50];       // надпись
    reference pTextItem;     // динамический массив компонент текта TEXT_ITEM_ARR  (надпись)
  };
  reference      pMathPoint; // POINT_ARR динамический массив  нач.точка, точки перегибов, кон.точка
};

#ifdef _UNICODE
#define CutLineParamT  CutLineParamW
#else
#define CutLineParamT  CutLineParam
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// структура параметров "стрелки вида"
// ---
struct ViewPointerParam {
  unsigned short style;      // стиль текста, если 0 - умолчательный стиль
  double         x1, y1;     // координаты вершины( острия) стрелки
  double         x2, y2;     // координаты конечной точки стрелки
  double         xt, yt;     // координаты текста
  unsigned char  type;       // 0- текст в виде строки 1- динамический массив компонент текстов
  union {
    char      str[50];       // надпись
    reference pTextItem;     // динамический массив компонент текта  TEXT_ITEM_ARR  (надпись)
  };
};

//-------------------------------------------------------------------------------
// структура параметров "стрелки вида"
// (Unicode)
// ---
struct ViewPointerParamW {
  unsigned short style;      // стиль текста, если 0 - умолчательный стиль
  double         x1, y1;     // координаты вершины( острия) стрелки
  double         x2, y2;     // координаты конечной точки стрелки
  double         xt, yt;     // координаты текста
  unsigned char  type;       // 0- текст в виде строки 1- динамический массив компонент текстов
  union {
    wchar_t   str[50];       // надпись
    reference pTextItem;     // динамический массив компонент текта  TEXT_ITEM_ARR  (надпись)
  };
};

#ifdef _UNICODE
#define ViewPointerParamT  ViewPointerParamW
#else
#define ViewPointerParamT  ViewPointerParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// структура параметров опоры допуска формы
// ---
struct ToleranceBranch {
  unsigned char arrowType;  // тип опоры  1- треугольник 2- стрелка 0-опору не учитывать
  unsigned char tCorner;    // 1-8 опрделяет точку на таблице куда приходит опора
  reference pMathPoint;     // динамический массив математических точек ( POINT_ARR  )
                            // первый узел -точка на таблице ( ее в массив помещать не нужно - определена tCorner1),
                            // остальные узлы - изломы( могут отсутствовать)
                            // последний узел - конец опоры (указывает на объект)
};


//-------------------------------------------------------------------------------
// структура параметров "допуска формы"
// ---
struct ToleranceParam {// 12.1.2001 устаревшая структура со временем будет убрана
  unsigned char  tBase;     // 1-8 опрделяет базовую точку на таблице ( 1- левый нижний угол   3..4..5  )
  unsigned short style;     // стиль текста, если 0 - умолчательное значение                   :     :
  double x, y;              // координаты базовой точки                                        2     6
  unsigned char type;       // тип  0- горизонтальное расположение, 1- вертикальное            :     :
  ToleranceBranch  branch1; // первая опора                                                    1..8..7
  ToleranceBranch  branch2; // вторая опора
};

//-------------------------------------------------------------------------------
// структура параметров "допуска формы"
// ---
struct ksTolerancePar {
  unsigned char  tBase;     // 1-8 опрделяет базовую точку на таблице ( 1- левый нижний угол   3..4..5  )
  unsigned short style;     // стиль текста, если 0 - умолчательное значение                   :     :
  double x, y;              // координаты базовой точки                                        2     6
  unsigned char type;       // тип  0- горизонтальное расположение, 1- вертикальное            :     :
  reference branchArr;      // динамический массив опор (структур ToleranceBranch )            1..8..7
};

// см. <ldefin2d.h> типы стилей
// CURVE_STYLE ...

//-------------------------------------------------------------------------------
// Структура параметров участка штриховой кривой
// ---
struct CurvePattern {
	double  visibleSeg;     // длина видимого участка
	double  invisibleSeg;   // длина невидимого участка
};

//-------------------------------------------------------------------------------
// Структура параметров для картинки стиля
// ---
struct  CurvePicture {
  reference      polygon; // динамический массив полилиний, описывающий картинку POLYLINE_ARR   ( точки в листовых координатах относительно 0 картинки)
  reference      fill;    // динамический массив точек, описывающий границу заливки POLYLINE_ARR (точки в листовых координатах относительно 0 картинки)
};

//-------------------------------------------------------------------------------
// Структура параметров участка штриховой кривой расширенная
// ---
struct CurvePatternEx {
	double         visibleSeg;      // длина видимого участка
	double         invisibleSeg;    // длина невидимого участка
  double         dx;              // положение баз.точки(нуля) картинки относительно начала образца
  double         dy;              //
  unsigned char  pictureType;     // тип картинки
  union {
    struct  CurvePicture picture; // pictureType 0 - картинка в виде массивов полилиний
  	char    frwName[TEXT_LENGTH]; // pictureType 1  картинка в виде фрагмента, используется только при создании стиля AddStyle
  };
};

//-------------------------------------------------------------------------------
// Структура параметров участка штриховой кривой расширенная
// (Unicode)
// ---
struct CurvePatternExW {
	double         visibleSeg;      // длина видимого участка
	double         invisibleSeg;    // длина невидимого участка
  double         dx;              // положение баз.точки(нуля) картинки относительно начала образца
  double         dy;              //
  unsigned char  pictureType;     // тип картинки
  union {
    struct  CurvePicture picture; // pictureType 0 - картинка в виде массивов полилиний
  	wchar_t frwName[TEXT_LENGTH]; // pictureType 1  картинка в виде фрагмента, используется только при создании стиля AddStyle
  };
};

#ifdef _UNICODE
#define CurvePatternExT  CurvePatternExW
#else
#define CurvePatternExT  CurvePatternEx
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// curveType | LIKE_BASIC_LINE - параметры пера как у  основной линии
// см. <ldefin2d.h> LIKE_BASIC_LINE ...
// структура параметров стиля кривой
// ---
struct CurveStyleParam {
 	char           name[TEXT_LENGTH]; // имя стиля
  unsigned long  color;             // цвет
  double         paperWidth;        // толщина пера на бумаге
  unsigned char  screenWidth;       // толщина пера на экране
  unsigned char  curveType;         // тип кривой 0- сплошная 1- прерывистая 2- прерывистая с картинками
  reference      pattern;           // (для прерывистой кривой) динамический массив параметров участков штриховой кривой для CURVE_STYLE-CurvePattern, для CURVE_STYLE_EX -CurvePatternEx
  unsigned char  even;              // (для прерывистой кривой) 1- кривая всегда оканчивается штрихами 0- как получится
};

//-------------------------------------------------------------------------------
// curveType | LIKE_BASIC_LINE - параметры пера как у  основной линии
// см. <ldefin2d.h> LIKE_BASIC_LINE ...
// структура параметров стиля кривой
// (Unicode)
// ---
struct CurveStyleParamW {
 	wchar_t        name[TEXT_LENGTH]; // имя стиля
  unsigned long  color;             // цвет
  double         paperWidth;        // толщина пера на бумаге
  unsigned char  screenWidth;       // толщина пера на экране
  unsigned char  curveType;         // тип кривой 0- сплошная 1- прерывистая 2- прерывистая с картинками
  reference      pattern;           // (для прерывистой кривой) динамический массив параметров участков штриховой кривой для CURVE_STYLE-CurvePattern, для CURVE_STYLE_EX -CurvePatternEx
  unsigned char  even;              // (для прерывистой кривой) 1- кривая всегда оканчивается штрихами 0- как получится
};

#ifdef _UNICODE
#define CurveStyleParamT  CurveStyleParamW
#else
#define CurveStyleParamT  CurveStyleParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// структура   составляющих объектов размера ( копии - временные объекты )
// ---
struct DimensionPartsParam {
  reference      line1;     // линия выноски 1
  reference      line2;     // линия выноски 2
  reference      dimLine;   // размерная  линия
  reference      dimLine1;  // продолжение размерной линии
  reference      leg;       // ножка
  reference      shelf;     // полка
  reference      gr;        // временная группа  всех объектов размера, включая тексты
  reference      curveExt;  // продление базовой кривой( у радиального размера), указатель текста ( у размера на дугу )
};

//-------------------------------------------------------------------------------
// структура параметров стиля текста
// ---
struct TextStyleParam {
  char           name[TEXT_LENGTH];      // имя стиля
  double         height;                 // высота текста
  double         ksu;                    // сужение текста
  double         step;                   // шаг строк
  char           fontName[TEXT_LENGTH];  // имя фонта
  unsigned long  color;                  // цвет
  unsigned char  align;                  // вырвнивание 0-слева, 1-по центру,2-справа, 3 -на всю ширину
  unsigned char  bold;                   // текст 1- утолщенный, 0-не утолщенный
  unsigned char  italic;                 // текст 1- с наклоном, 0- без наклона
  unsigned char  underline;              // текст 1- с подчеркиванием, 0 - без подчеркивания
  double         posKS;                  // смещение красной строки
  double         stepParPre;             // смещение вниз, предшествующее текту
  double         stepParPst;             // смещение вниз после текста
  double         leftEdge;               // отступ текста слева
  double         rightEdge;              // отступ текста справа
};

//-------------------------------------------------------------------------------
// структура параметров стиля текста
// (Unicode)
// ---
struct TextStyleParamW {
  wchar_t        name[TEXT_LENGTH];      // имя стиля
  double         height;                 // высота текста
  double         ksu;                    // сужение текста
  double         step;                   // шаг строк
  wchar_t        fontName[TEXT_LENGTH];  // имя фонта
  unsigned long  color;                  // цвет
  unsigned char  align;                  // вырвнивание 0-слева, 1-по центру,2-справа, 3 -на всю ширину
  unsigned char  bold;                   // текст 1- утолщенный, 0-не утолщенный
  unsigned char  italic;                 // текст 1- с наклоном, 0- без наклона
  unsigned char  underline;              // текст 1- с подчеркиванием, 0 - без подчеркивания
  double         posKS;                  // смещение красной строки
  double         stepParPre;             // смещение вниз, предшествующее текту
  double         stepParPst;             // смещение вниз после текста
  double         leftEdge;               // отступ текста слева
  double         rightEdge;              // отступ текста справа
};

#ifdef _UNICODE
#define TextStyleParamT  TextStyleParamW
#else
#define TextStyleParamT  TextStyleParam
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// структура параметров для построения конического сечения
// ---
struct ConicArcParam {
 double         A;
 double         B;
 double         C;
 double         D;
 double         E;
 double         F;      // коэффициенты канонического уравнения
 double x1; double y1;  // координаты начальной точки
 double x2; double y2;  // координаты конечной точки
 unsigned short style;  // стиль
};

//-------------------------------------------------------------------------------
// структура параметров для полилинии
// ---
struct PolylineParam {
 reference      pMathPoint; // динамический массив  мат точек  POINT_ARR
 unsigned short style;      // стиль
};

//-------------------------------------------------------------------------------
// структура параметров для полилинии. Расширенная
// ---
struct PolylineParamEx {
	reference      pMathPoint; // динамический массив  мат точек  POINT_ARR
	unsigned short style;      // стиль
	unsigned char  closed;     // признак замкнутой кривой - 1 кривая замкнута, 0 незамкнута
	char           rezerv[10]; // не используется
};

//-------------------------------------------------------------------------------
// структура параметров для подключения стиля из библиотеки
// ---
struct LibStyle {
  char          fileName [MAX_TEXT_LENGTH];// имя файла библиотеки
  int           styleNumber;               // номер стиля в библиотеке
  unsigned char typeAllocation;            // тип размещения стиля в докумкнте 0- телом; 1- ссылкой на  библиотеку
};

//-------------------------------------------------------------------------------
// структура параметров для подключения стиля из библиотеки
// (Unicode)
// ---
struct LibStyleW {
  wchar_t       fileName [MAX_TEXT_LENGTH];// имя файла библиотеки
  int           styleNumber;               // номер стиля в библиотеке
  unsigned char typeAllocation;            // тип размещения стиля в докумкнте 0- телом; 1- ссылкой на  библиотеку
};

#ifdef _UNICODE
#define LibStyleT  LibStyleW
#else
#define LibStyleT  LibStyle
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// структура параметров для определения технических требований
// ---
struct TechnicalDemandParam {
  reference pGab;          // динамический массив габаритных прямоугольников RECT_ARR -(структура RectParam)
  unsigned short style;    // стиль
  unsigned short strCount; // количество строк в технических требований
};

//-------------------------------------------------------------------------------
// структура параметров для определения неуказанной шероховатости
// ---
struct SpecRoughParam {
  unsigned short style;          // стиль текста
  unsigned char  sign;           // тип знака 0-вид обр-ки не устанавливается, 1- обр-ка удалением слоя материала, 2 -обр-ка без удаления слоя материала
  unsigned char  t;              // 1- есть знак в скобках 0 -нет
  char           s[TEXT_LENGTH]; // текст
};

//-------------------------------------------------------------------------------
// структура параметров для определения неуказанной шероховатости
// ( Unicode )
// ---
struct SpecRoughParamW {
  unsigned short style;          // стиль текста
  unsigned char  sign;           // тип знака 0-вид обр-ки не устанавливается, 1- обр-ка удалением слоя материала, 2 -обр-ка без удаления слоя материала
  unsigned char  t;              // 1- есть знак в скобках 0 -нет
  wchar_t        s[TEXT_LENGTH]; // текст
};

#ifdef _UNICODE
#define SpecRoughParamT  SpecRoughParamW
#else
#define SpecRoughParamT  SpecRoughParam
#endif // !_UNICODE


// см. <ldefin2d.h> Определения для функций GetDocOptions
// DIMENTION_OPTIONS ...

//-------------------------------------------------------------------------------
// структура параметров для определения настроек размеров
// ---
struct DimensionsOptions {
  double proLineExtension;        // выход выносных линий за размерную
  double textDistanceFromDimLine; // расстояние от разм.линии до текста
  double textDistanceFromProLine; // расстояние от выносных линий до текста
  double dimLineExtension;        // выход размерной линии за текст
  double arrowLength;             // длина стрелки для размера

  unsigned short style;  //стиль текста

  unsigned char decimalsCount;  // кол-во знаков после запятой 0-9
  int anglePrecisionLevel;      // точность углового размера 0-градусы, 1- минуты, 2- секунды
  int hiddenToleranceNumber;    // -1 не включен; максимальный номер показываемого квалитета  1-17
};


//-------------------------------------------------------------------------------
// см. <ldefin2d.h> типы колонок для спецификации
// SPC_CLM_FORMAT ...
// см. <ldefin2d.h> типы значений для колонки спецификации
// SPC_INT ...
// структура параметров для колонки спецификации
// ---
struct SpcColumnParam {
  unsigned int  columnType;          // тип колонки SPC_CLM_FORMAT...SPC_CLM_USER
  unsigned int  ispoln;              // исполнение данного типа начиная
  unsigned int  block;               // номер блока
  unsigned int  typeVal;             // тип значения используются : LINT_ATTR_TYPE,
  											          	 // DOUBLE_ATTR_TYPE, STRING_ATTR_TYPE, RECORD_ATTR_TYPE
  char          name[ TEXT_LENGTH ]; // имя колонки
};

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> типы колонок для спецификации
// SPC_CLM_FORMAT ...
// см. <ldefin2d.h> типы значений для колонки спецификации
// SPC_INT ...
// структура параметров для колонки спецификации
// (Unicode)
// ---
struct SpcColumnParamW {
  unsigned int  columnType;          // тип колонки SPC_CLM_FORMAT...SPC_CLM_USER
  unsigned int  ispoln;              // исполнение данного типа начиная
  unsigned int  block;               // номер блока
  unsigned int  typeVal;             // тип значения используются : LINT_ATTR_TYPE,
  											          	 // DOUBLE_ATTR_TYPE, STRING_ATTR_TYPE, RECORD_ATTR_TYPE
  wchar_t       name[ TEXT_LENGTH ]; // имя колонки
};

#ifdef _UNICODE
#define SpcColumnParamT  SpcColumnParamW
#else
#define SpcColumnParamT  SpcColumnParam
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> типы блиотек стилей
// CURVE_STYLE_LIBRARY ...   в ф. ksGetLibraryStylesArray 
// структура параметров для стиля в библиотеке стилей
// ---
struct LibraryStyleParam {
  char           styleName [MAX_TEXT_LENGTH]; // имя  стиля
  unsigned int   styleId;                     // номер стиля в библиотеке
};

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> типы блиотек стилей
// CURVE_STYLE_LIBRARY ...   в ф. ksGetLibraryStylesArray 
// структура параметров для стиля в библиотеке стилей
// (Unicode)
// ---
struct LibraryStyleParamW {
  wchar_t        styleName [MAX_TEXT_LENGTH]; // имя  стиля
  unsigned int   styleId;                     // номер стиля в библиотеке
};

#ifdef _UNICODE
#define LibraryStyleParamT  LibraryStyleParamW
#else
#define LibraryStyleParamT  LibraryStyleParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// структура параметров для расчета плоских моментно-центровочных характеристик
// см. <ldefin2d.h> размерности и типы детали для рассчета массо-ценровочных характеристик
// ST_MIX_MM ...
// ---
struct InertiaParam {
  double xc, yc;      // координаты центра тяжести,
  double f;           // площадь,
  double ly, lx;      // осевые       моменты инерции относительно исходных осей координат x и y,
  double lxy;         // центробежный момент  инерции относительно исходных осей координат  x и y,
  double my, mx;      // осевые       моменты инерции относительно центральных осей (относительно осей, параллельных исходных осям и проходящих черех центр тяжести)
  double mxy;         // центробежный момент  инерции относительно центральных осей (относительно осей, параллельных исходных осям и проходящих черех центр тяжести)
  double jy, jx;      // главные центральные моменты инерции,
  double a;           // угол между первой главной осью и осью x
};

//-------------------------------------------------------------------------------
// структура параметров для расчета массо-центровочных характеристик
// см. <ldefin2d.h> размерности и типы детали для рассчета массо-ценровочных характеристик
// ST_MIX_MM ...
// ---
struct MassInertiaParam {
  double  r;               // плотность
  double  m;               // масса
  double  v;               // объем
  double  xc,   yc,   zc;  // координаты центра тяжести
  double  lxy,  lxz,  lyz; // центробежные моменты инерции относительно исходных осей координат
  double  lx,   ly,   lz;  // осевые       моменты инерции относительно исходных осей координат
  double  jy0z, jx0z, jx0y;// плоскостные  моменты инерции (интегралы инерции) относительно центральных осей координат
  double  jxy,  jxz,  jyz; // центробежные моменты инерции относительно центральных осей координат
  double  jx,   jy,   jz;  // осевые       моменты инерции относительно центральных осей координат
};

//-------------------------------------------------------------------------------
// структура  параметров параметрической переменной
// ---
struct VariableParam {
  char    name [MAX_TEXT_LENGTH];// имя  переменной
  double  value;                 // значение переменной
  char    note[MAX_TEXT_LENGTH]; // комментарий
};

//-------------------------------------------------------------------------------
// структура  параметров параметрической переменной
// (Unicode)
// ---
struct VariableParamW {
  wchar_t name [MAX_TEXT_LENGTH];// имя  переменной
  double  value;                 // значение переменной
  wchar_t note[MAX_TEXT_LENGTH]; // комментарий
};

#ifdef _UNICODE
#define VariableParamT  VariableParamW
#else
#define VariableParamT  VariableParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// см. <ldefin2d.h> тип локальной привязки
// SN_NEAREST_POINT ...
// см. <ldefin2d.h> типы общих настроек для привязок
// SN_DYNAMICALLY ...
//структура параметров привязок в графическом документе
// ---
struct SnapOptions {
  //глобальные привязки
  unsigned char nearestPoint;      // Ближайшая точка
  unsigned char nearestMiddle;     // Середина
  unsigned char intersect;         // Пересечение
  unsigned char tangentToCurve;    // Касание
  unsigned char normalToCurve;     // Нормаль
  unsigned char grid;              // По сетке
  unsigned char xyAlign;           // Выравнивание
  unsigned char angSnap;           // Угловая привязка
  unsigned char pointOnCurve;      // Точка на кривой

  unsigned int  commonOpt;         // общие настройки привязок : динамически отслеживать, отображать текст, с учетом фоновых слоев, подавить привязки
  double        angleStep;         // угловой шаг для привязок по ортогональности
  unsigned char localSnap;         // установить тип локальной привязки SN_NEAREST_POINT...SN_POINT_CURVE или 0
};

// см. <ldefin2d.h>  Определения для функций GetSysOptions и  SetSysOptions
// SNAP_OPTIONS ...


//-------------------------------------------------------------------------------
// структура параметров  Nurbs-сплайна
// ---
struct NurbsParam {
  unsigned  char  degree;   // степень сплайна > 2 && < 9
  unsigned  char  close;    // тип замыкания сплайна 0 - незамкнутый 1 - замкнутый
  unsigned  short style;    // стиль отрисовки сплайна
  reference       pPoint;   // динамический массив  точек сплайна(NurbsPointParam )
  reference       pKnot;    // динамический массив  узлов сплайна(double)
  unsigned  char  periodic; // 1 - сплайн периодический; 0 - не периодический -только GetObjParam
};

//-------------------------------------------------------------------------------
// структура параметров  вставки фрагментов
// ---
struct InsertFragmentParam {
  PlacementParam  place;        // структура местоположения вставки фрагмента
  unsigned  char  insertType;   // тип вставки
                                // 0- взять в документ, 1-внешней ссылкой, 3- локальный фрагмент
  unsigned char   multiLayer;   // признак 1 - многослойный объект, 0 - однослойный
  
  char            fileName[MAX_TEXT_LENGTH]; // имя файла фрагмента или "\0" для локального фрагмента
  char            comment[MAX_TEXT_LENGTH];  // имя вставки
};

//-------------------------------------------------------------------------------
// структура параметров вставки фрагментов
// (Unicode)
// ---
struct InsertFragmentParamW {
  PlacementParam  place;        // структура местоположения вставки фрагмента
  unsigned  char  insertType;   // тип вставки
                                // 0- взять в документ, 1-внешней ссылкой, 3- локальный фрагмент
  unsigned char   multiLayer;   // признак 1 - многослойный объект, 0 - однослойный
  
  wchar_t         fileName[MAX_TEXT_LENGTH]; // имя файла фрагмента или "\0" для локального фрагмента
  wchar_t         comment[MAX_TEXT_LENGTH];  // имя вставки
};

#ifdef _UNICODE
#define InsertFragmentParamT  InsertFragmentParamW
#else
#define InsertFragmentParamT  InsertFragmentParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// расширенная структура параметров вставки фрагментов 
// ---
struct InsertFragmentParamEx {
  PlacementParam place;                      // структура местоположения вставки фрагмента
  unsigned  char insertType;                 // тип вставки
                                             // 0- взять в документ, 1-внешней ссылкой, 3- локальный фрагмент
  unsigned char  multiLayer;                 // признак 1 - многослойный объект, 0 - однослойный
  char           fileName [MAX_TEXT_LENGTH]; // имя файла фрагмента или "\0" для локального фрагмента
  char           comment  [MAX_TEXT_LENGTH]; // имя вставки
  unsigned char  scaleProjLinesSize;         // масштабировать ли длину выносных линий у размеров
};

//-------------------------------------------------------------------------------
// расширенная структура параметров вставки фрагментов 
// (Unicode)
// ---
struct InsertFragmentParamExW {
  PlacementParam place;                      // структура местоположения вставки фрагмента
  unsigned  char insertType;                 // тип вставки
                                             // 0- взять в документ, 1-внешней ссылкой, 3- локальный фрагмент
  unsigned char  multiLayer;                 // признак 1 - многослойный объект, 0 - однослойный
  wchar_t        fileName [MAX_TEXT_LENGTH]; // имя файла фрагмента или "\0" для локального фрагмента
  wchar_t        comment  [MAX_TEXT_LENGTH]; // имя вставки
  unsigned char  scaleProjLinesSize;         // масштабировать ли длину выносных линий у размеров
};

#ifdef _UNICODE
#define InsertFragmentParamExT  InsertFragmentParamExW
#else
#define InsertFragmentParamExT  InsertFragmentParamEx
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// см. <ldefin2d.h> Типы параметрических ограничений
// CONSTRAINT_FIXED_POINT ...
// Структура параметров параметрических ограничений
// ---
struct ConstraintParam {
  unsigned short  constrType;    // тип ограничения
  int             index;         // индекс точки на объекте ( начинается с 0, у дуги и окружности 0-центр )
  reference       partner;       // второй объект
  int             partnerIndex;  // индекс точки на втором объекте ( начинается с 0, у дуги и окружности 0-центр )
};

//-------------------------------------------------------------------------------
// структура параметров углов для прямоугольников и многоугольников
// ---
struct CornerParam {
  int           index;  // индекс угла ( 0, 1, 2, .... )
  unsigned char fillet; // признак скругления 1 - скругление, 0 - фаска
  double        l1;     // длина фаски 1 сегмента или радиус
  double        l2;     // длина фаски 2 сегмента
};

//-------------------------------------------------------------------------------
// структура параметров прямоугольника
// ---
struct RectangleParam {
	double         x;          // базовая точка 1
  double         y;
  double         ang;        // угол вектора направления от 1-ой точки ко 2-ой
  double         height;     // высота
  double         width;      // ширина
	unsigned short style;      // тип линии
  reference      pCorner;    // динамический массив структур параметров углов CORNER_ARR
};

//-------------------------------------------------------------------------------
// структура параметров правильного многоугольника
// ---
struct RegularPolygonParam {
  int            count;         // количество вершин многоугольника
  double         xc;            // центр окружности
  double         yc;
  double         ang;           // угол первой вершины
  double         radius;        // радиус окружности
  unsigned char  describe;      // признак описанного многоугольника.
	unsigned short style;         // тип линии
  reference      pCorner;       // динамический массив структур параметров углов CORNER_ARR
};

//-------------------------------------------------------------------------------
// структура параметров объекта "обозначение центра"
// ---
struct CentreParam {
  reference	    baseCurve;  // базовая ГЕОМЕТРИЧЕСКАЯ кривая или 0
  double        x, y;       // точка привязки, если baseCurve задана - не используется
  double        ang;        // направление, если baseCurve задана - не используется
  unsigned char type;       // тип обозначений центра 0- спецзнак, 1- горизонтальная ось 2- обе оси
  unsigned char standXpTail;// 1- признак "стандартного" хвоста
  unsigned char standXmTail;//
  unsigned char standYpTail;//
  unsigned char standYmTail;//
  double        lenXpTail;  // длина хвоста, если он не стандартный
  double        lenXmTail;
  double        lenYpTail;
  double        lenYmTail;
};

//-------------------------------------------------------------------------------
// параметры присоединеного документа к объекту спецификации
// ---
struct DocAttachedSpcParam {
  char          fileName[MAX_TEXT_LENGTH]; // имя файла документа источника
  char          comment[MAX_TEXT_LENGTH];  // комментарий для документа источника
  unsigned char transmit;                  // 1 - при изменении обозначения-наименования передавать в изменения в источник
};

//-------------------------------------------------------------------------------
// параметры присоединеного документа к объекту спецификации
// (Unicode)
// ---
struct DocAttachedSpcParamW {
  wchar_t       fileName[MAX_TEXT_LENGTH]; // имя файла документа источника
  wchar_t       comment[MAX_TEXT_LENGTH];  // комментарий для документа источника
  unsigned char transmit;                  // 1 - при изменении обозначения-наименования передавать в изменения в источник
};

#ifdef _UNICODE
#define DocAttachedSpcParamT  DocAttachedSpcParamW
#else
#define DocAttachedSpcParamT  DocAttachedSpcParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// см. <ldefin2d.h> типы объектов спецификации
// SPC_BASE_OBJECT ...
// структура параметров объекта спецификации
// ---
struct SpcObjParam {
  reference      docArr;         // динамический массив DOC_SPCOBJ_ARR структур параметров прикрепленных документов к объекту спецификации

  // параметры для всех типов объектов
  unsigned short typeObj;        // тип объекта - SPC_BASE_OBJECT ... SPC_EMPTY_STR !!! только для чтения !!!
  unsigned short numbSection;    // номер раздела                                   !!! только для чтения !!!

  // параметры для вспомогательного объекта - комментарий
  unsigned short blockNumber;    // номер блока ( первый - 0 ) для SPC_COMMENT - комментарий

  // параметры для вспомогательного и базового объекта
  unsigned short numbSubSection; // номер подраздела
  char           subSectionName[MAX_TEXT_LENGTH]; // имя подраздела !!! только для чтения !!!
  unsigned char  firstOnSheet;   // 1 - первый на листе
  unsigned char  insFrgType;     // 0 - самостоятельный объект,     1 - объект из вставки фрагмента
                                 // 2 - редактировался в документе  !!! только для чтения !!!
  unsigned char  posInc;         // 1 - позиция возрастает; 0 - позиция соответствует предыдущей

  // параметры только для базового объекта
  unsigned char  first;          // 1 - первый одинаковый объект, 0 - последующие одинаковые объекты !!! только для чтения !!!
  unsigned char  draw;           // 1 - объект показывать  0 - объект не показывать ( для одинаковых объектов )
  unsigned char  posNotDraw;     // 0 - позицию показывать в таблице 1 не показывать
  unsigned char  ispoln;         // 1 - объект является исполнением
};

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> типы объектов спецификации
// SPC_BASE_OBJECT ...
// структура параметров объекта спецификации
// (Unicode)
// ---
struct SpcObjParamW {
  reference      docArr;         // динамический массив DOC_SPCOBJ_ARR структур параметров прикрепленных документов к объекту спецификации

  // параметры для всех типов объектов
  unsigned short typeObj;        // тип объекта - SPC_BASE_OBJECT ... SPC_EMPTY_STR !!! только для чтения !!!
  unsigned short numbSection;    // номер раздела                                   !!! только для чтения !!!

  // параметры для вспомогательного объекта - комментарий
  unsigned short blockNumber;    // номер блока ( первый - 0 ) для SPC_COMMENT - комментарий

  // параметры для вспомогательного и базового объекта
  unsigned short numbSubSection; // номер подраздела
  wchar_t        subSectionName[MAX_TEXT_LENGTH]; // имя подраздела !!! только для чтения !!!
  unsigned char  firstOnSheet;   // 1 - первый на листе
  unsigned char  insFrgType;     // 0 - самостоятельный объект,     1 - объект из вставки фрагмента
                                 // 2 - редактировался в документе  !!! только для чтения !!!
  unsigned char  posInc;         // 1 - позиция возрастает; 0 - позиция соответствует предыдущей

  // параметры только для базового объекта
  unsigned char  first;          // 1 - первый одинаковый объект, 0 - последующие одинаковые объекты !!! только для чтения !!!
  unsigned char  draw;           // 1 - объект показывать  0 - объект не показывать ( для одинаковых объектов )
  unsigned char  posNotDraw;     // 0 - позицию показывать в таблице 1 не показывать
  unsigned char  ispoln;         // 1 - объект является исполнением
};

#ifdef _UNICODE
#define SpcObjParamT  SpcObjParamW
#else
#define SpcObjParamT  SpcObjParam
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// структура параметров растрового объекта
// ---
struct RasterParam {
	PlacementParam place;                      // структура местоположения
  char           fileName[MAX_TEXT_LENGTH];  // полный путь к файлу
  unsigned char  embeded;                    // embeded - 1 - внедрять данные в объект,
   													                 // 0 - связывать с файлом на диске (пока не используется)
};

//-------------------------------------------------------------------------------
// структура параметров растрового объекта
// (Unicode)
// ---
struct RasterParamW {
	PlacementParam place;                      // структура местоположения
  wchar_t        fileName[MAX_TEXT_LENGTH];  // полный путь к файлу
  unsigned char  embeded;                    // embeded - 1 - внедрять данные в объект,
   													                 // 0 - связывать с файлом на диске (пока не используется)
};

#ifdef _UNICODE
#define RasterParamT  RasterParamW
#else
#define RasterParamT  RasterParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// заполняется для типа значения RECORD_ATTR_TYPE
// ---
struct RecordTypeAttrParam {
  char attrLibName[MAX_TEXT_LENGTH];  // имя файла библиотеки типов атрибутов

  int  key1;                          // атрибуты многих типов  задавать ключами
  int  key2;                          // если какой-то из ключей 0 он не учитывается
  int  key3;
  int  key4;
};

//-------------------------------------------------------------------------------
// заполняется для типа значения RECORD_ATTR_TYPE
// (Unicode)
// ---
struct RecordTypeAttrParamW {
  wchar_t attrLibName[MAX_TEXT_LENGTH];  // имя файла библиотеки типов атрибутов

  int     key1;                          // атрибуты многих типов  задавать ключами
  int     key2;                          // если какой-то из ключей 0 он не учитывается
  int     key3;
  int     key4;
};

#ifdef _UNICODE
#define RecordTypeAttrParamT  RecordTypeAttrParamW
#else
#define RecordTypeAttrParamT  RecordTypeAttrParam
#endif // !_UNICODE


// заполняется для типа значения DOUBLE_ATTR_TYPE и LINT_ATTR_TYPE
struct NumberTypeAttrParam {
  double minValue;
  double maxValue;
};

//-------------------------------------------------------------------------------
// структура параметров стиля колонки таблицы спецификации
// тип запись вводится только в целях сортировки
// ---
struct SpcStyleColumnParam {
  char          nameColumn[MAX_TEXT_LENGTH];  // имя колонки
  unsigned int  columnType;         // тип колонки SPC_CLM_FORMAT ... SPC_CLM_FACTORY
  unsigned int  ispoln;             // номер колонки с данным типом

  unsigned char edit;               // 1 - редактировать колонку в данном разделе, 0 - нет
  unsigned char createSum;          // 1 - расчитывать сумму значений для колонки, 0 - нет
  unsigned char multiplyToCount;    // 1 - при расчете суммы домножать на количество, 0 - нет
  unsigned char useForSectionTitle; // 1 - использовать колонку для вывода имени раздела, 0 - нет
  unsigned char textDn;             // 1 - тест колонки прижимать к низу, 0 - приживать к верху
  char          rezerv[10];         // не используется

  unsigned int  linkId;             // номер ячейки штампа для связи

  unsigned int  typeVal;            // тип значения используются : LINT_ATTR_TYPE,
  																	// DOUBLE_ATTR_TYPE, STRING_ATTR_TYPE, RECORD_ATTR_TYPE
  union {
    RecordTypeAttrParam recordType; // заполняется для типа значения RECORD_ATTR_TYPE
    NumberTypeAttrParam numberType; // заполняется для типа значения DOUBLE_ATTR_TYPE и LINT_ATTR_TYPE
  };
};

//-------------------------------------------------------------------------------
// структура параметров стиля колонки таблицы спецификации
// тип запись вводится только в целях сортировки
// (Unicode)
// ---
struct SpcStyleColumnParamW {
  wchar_t       nameColumn[MAX_TEXT_LENGTH];  // имя колонки
  unsigned int  columnType;          // тип колонки SPC_CLM_FORMAT ... SPC_CLM_FACTORY
  unsigned int  ispoln;              // номер колонки с данным типом

  unsigned char edit;                // 1 - редактировать колонку в данном разделе, 0 - нет
  unsigned char createSum;           // 1 - расчитывать сумму значений для колонки, 0 - нет
  unsigned char multiplyToCount;     // 1 - при расчете суммы домножать на количество, 0 - нет
  unsigned char useForSectionTitle;  // 1 - использовать колонку для вывода имени раздела, 0 - нет
  unsigned char textDn;              // 1 - тест колонки прижимать к низу, 0 - приживать к верху
  char          rezerv[10];          // не используется

  unsigned int  linkId;              // номер ячейки штампа для связи

  unsigned int  typeVal;             // тип значения используются : LINT_ATTR_TYPE,
  											  				   // DOUBLE_ATTR_TYPE, STRING_ATTR_TYPE, RECORD_ATTR_TYPE
  union {
    RecordTypeAttrParamW recordType; // заполняется для типа значения RECORD_ATTR_TYPE
    NumberTypeAttrParam  numberType; // заполняется для типа значения DOUBLE_ATTR_TYPE и LINT_ATTR_TYPE
  };
};

#ifdef _UNICODE
#define SpcStyleColumnParamT  SpcStyleColumnParamW
#else
#define SpcStyleColumnParamT  SpcStyleColumnParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// см. <ldefin2d.h> типы сортировки
// SPC_SORT_OFF ...
// структура параметров стиля разделa спецификации
// ---
struct SpcStyleSectionParam {
  char           sectionName[MAX_TEXT_LENGTH]; // имя раздела
  unsigned short number;                       // номер раздела
  unsigned int   sortColumnType;               // общий тип колонки в которой проводить сортировку
  unsigned int   sortIspoln;                   // номер колонки в которой проводить сортировку

  unsigned char  dataType;                     // тип заполнения данных: 0 - ручное заполнение колонок,
                                               //                        1 - ручное заполнение или чтение из штампа
  unsigned short sortType;                     // тип сортировки SPC_SORT_OFF ... SPC_SORT_DOWN
  reference      arrColumn;                    // массив структур параметров стиля колонок SpcStyleColumnParam
  reference      arrAdditionalColumn;          // массив структур параметров стиля
  															               // дополнительных колонок SpcStyleColumnParam
  char           rezerv[10];                   // не используется
};

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> типы сортировки
// SPC_SORT_OFF ...
// структура параметров стиля разделa спецификации
// (Unicode)
// ---
struct SpcStyleSectionParamW {
  wchar_t        sectionName[MAX_TEXT_LENGTH]; // имя раздела
  unsigned short number;                       // номер раздела
  unsigned int   sortColumnType;               // общий тип колонки в которой проводить сортировку
  unsigned int   sortIspoln;                   // номер колонки в которой проводить сортировку

  unsigned char  dataType;                     // тип заполнения данных: 0 - ручное заполнение колонок,
                                               //                        1 - ручное заполнение или чтение из штампа
  unsigned short sortType;                     // тип сортировки SPC_SORT_OFF ... SPC_SORT_DOWN
  reference      arrColumn;                    // массив структур параметров стиля колонок SpcStyleColumnParam
  reference      arrAdditionalColumn;          // массив структур параметров стиля
  															               // дополнительных колонок SpcStyleColumnParam
  char           rezerv[10];                   // не используется
};

#ifdef _UNICODE
#define SpcStyleSectionParamT  SpcStyleSectionParamW
#else
#define SpcStyleSectionParamT  SpcStyleSectionParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// структура параметров подраздела спецификации. Разделы могут состоять из подразделов
// ---
struct SpcSubSectionParam {
  char           name[MAX_TEXT_LENGTH]; //имя подраздела
  unsigned short number;                //номер подраздела
};

//-------------------------------------------------------------------------------
// структура параметров подраздела спецификации. Разделы могут состоять из подразделов
// (Unicode)
// ---
struct SpcSubSectionParamW {
  wchar_t        name[MAX_TEXT_LENGTH]; //имя подраздела
  unsigned short number;                //номер подраздела
};

#ifdef _UNICODE
#define SpcSubSectionParamT  SpcSubSectionParamW
#else
#define SpcSubSectionParamT  SpcSubSectionParam
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// структура параметров настройки раздела спецификации
// ---
struct SpcTuningSectionParam {
  unsigned char  subsectionOn;  // 1-деление на подразделы включено, 0-не включено
  unsigned char  geometryOn;    // 1-геометрию ставить в разделе, 0-не ставить
  unsigned char  positionOn;    // 1-позиции ставить в разделе, 0- не ставить
  unsigned char  sortOn;        // 1-сортировка включена, 0-выключена для настройки
  unsigned char  firstOnSheet;  // 1- раздел размещать с новой страницы, 0-выключена

  char           rezerv[10];    // не используется

  unsigned short rezervCount;   // число резервных строк и позиций
  unsigned short number;        // номер раздела - только для чтения

  reference      arrSubSection; // массив параметров подразделов SpcSubSectionParam для раздела
};

//-------------------------------------------------------------------------------
// структура параметров стиля настроек спецификации
// ---
struct SpcTuningStyleParam {
  unsigned char grToSP;                    // режим связки CБ -> СП 0-нет; 1-только вставка ЭС; 2-с расчетом позиций;
  unsigned char zoneCalc;                  // 1- рассчитывать зоны, 0-не включено
  unsigned char showSectionName;           // 1-показывать имя раздела в таблице, 0-не включено
  unsigned char positionCalc;              // 1-позиции рассчитывать в СП, 0-не включено
  unsigned char geometryDel;               // 1-геометрию удалять при удалении ЭС, 0-не удалять
  unsigned char positionDel;               // зарезервировано
  unsigned char massCalc;                  // зарезервировано
  unsigned char disableEmptyStr;           // запретить вывод пустых строк вокруг заголовка раздела
  unsigned char insertNull;                // настройка начала блока 1- вставлять нули перед числом 0-не вставлять
  unsigned char insertDash;                // настройка начала блока 1- вставлять тире 0-не вставлять
  unsigned char disableEmptyBlockStr;      // запретить вывод пустых строк вокруг начала блока
  unsigned char showInfoByDetBlock;        // 0-выдавать информацию блоками  1- подетально ( для исполнений > 10 )
  unsigned char ispolnOn;                  // 1-исполнения поддерживаются в спецификации
  unsigned char ispolnMarkFull;            // 1-обозначение исполнения показывать полностью 0 - только номер (-01)
  unsigned char blocOnNewPage;             // Располагать блок на новой странице
  unsigned char userTextStyle;             // 1- стиль текста объектов СП пользовательский

  unsigned char  countIspoln;              // число исполнений;  для совместимости  заполняется для исполнений <= 255  и countIspolnEx == 0
  unsigned char  countBlock;               // число блоков       для совместимости  заполняется для исполнений <= 255  и countBlockEx == 0
  unsigned short countIspolnEx;            // число исполнений
  unsigned short countBlockEx;             // число блоков
  unsigned char  delSpcObjOnDelGeometry;   // удалять объекты спецификации при удалении геометрии
  unsigned char  copySpcObjOnCopyGeometry; // копировать объекты спецификации при копировании геометрии 
  char           rezerv[4];                // не используется

  TextStyleParam sectionTextStyleFirst;    // стиль текста заголовка раздела - первая строка
  TextStyleParam sectionTextStyleNext;     // стиль текста заголовка раздела - последующие строки
  TextStyleParam objectTextStyle;          // стиль текста объекта спецификации

  char           predefinedTextFileName[MAX_TEXT_LENGTH];
  reference      arrSection;             // массив настроек разделов для спецификации SpcTuningSectionParam
};

//-------------------------------------------------------------------------------
// структура параметров стиля настроек спецификации
// (Unicode)
// ---
struct SpcTuningStyleParamW {
  unsigned char grToSP;                  // режим связки CБ -> СП 0-нет; 1-только вставка ЭС; 2-с расчетом позиций;
  unsigned char zoneCalc;                // 1- рассчитывать зоны, 0-не включено
  unsigned char showSectionName;         // 1-показывать имя раздела в таблице, 0-не включено
  unsigned char positionCalc;            // 1-позиции рассчитывать в СП, 0-не включено
  unsigned char geometryDel;             // 1-геометрию удалять при удалении ЭС, 0-не удалять
  unsigned char positionDel;             // зарезервировано
  unsigned char massCalc;                // зарезервировано
  unsigned char disableEmptyStr;         // запретить вывод пустых строк вокруг заголовка раздела
  unsigned char insertNull;              // настройка начала блока 1- вставлять нули перед числом 0-не вставлять
  unsigned char insertDash;              // настройка начала блока 1- вставлять тире 0-не вставлять
  unsigned char disableEmptyBlockStr;    // запретить вывод пустых строк вокруг начала блока
  unsigned char showInfoByDetBlock;      // 0-выдавать информацию блоками  1- подетально ( для исполнений > 10 )
  unsigned char ispolnOn;                // 1-исполнения поддерживаются в спецификации
  unsigned char ispolnMarkFull;          // 1-обозначение исполнения показывать полностью 0 - только номер (-01)
  unsigned char blocOnNewPage;           // Располагать блок на новой странице
  unsigned char userTextStyle;           // 1- стиль текста объектов СП пользовательский

  unsigned char  countIspoln;              // число исполнений;  для совместимости  заполняется для исполнений <= 255  и countIspolnEx == 0
  unsigned char  countBlock;               // число блоков       для совместимости  заполняется для исполнений <= 255  и countBlockEx == 0
  unsigned short countIspolnEx;            // число исполнений
  unsigned short countBlockEx;             // число блоков
  unsigned char  delSpcObjOnDelGeometry;   // удалять объекты спецификации при удалении геометрии
  unsigned char  copySpcObjOnCopyGeometry; // копировать объекты спецификации при копировании геометрии 
  char           rezerv[4];                // не используется

  TextStyleParamW sectionTextStyleFirst;  // стиль текста заголовка раздела - первая строка
  TextStyleParamW sectionTextStyleNext;   // стиль текста заголовка раздела - последующие строки
  TextStyleParamW objectTextStyle;        // стиль текста объекта спецификации

  wchar_t         predefinedTextFileName[MAX_TEXT_LENGTH];
  reference       arrSection;             // массив настроек разделов для спецификации SpcTuningSectionParam
};

#ifdef _UNICODE
#define SpcTuningStyleParamT  SpcTuningStyleParamW
#else
#define SpcTuningStyleParamT  SpcTuningStyleParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// структура параметров стиля спецификации
// ---
struct SpcStyleParam {
  char                layoutName1[MAX_TEXT_LENGTH];  // имя файла библиотеки оформлений для первого листа
  char                layoutName2[MAX_TEXT_LENGTH];  // имя файла библиотеки оформлений для второго листа
  unsigned int        shtType1;                      // тип оформления в библиотеке для первого листа
  unsigned int        shtType2;                      // тип оформления для второго листа

  unsigned char       variant;             // вариант оформления спецификации  0-простая, 1-А, 2-Б, 3-В, 4-Г
  unsigned char       sectionOn;           // 1- включено деление на разделы, 0-не включено
  char                rezerv[10];          // не используется

  SpcTuningStyleParam tuning;              // умолчательные настройки, считанные с библиотеки спецификации

  reference           arrColumn;           // массив колонок для спецификации -умолчательные значения SpcStyleColumnParam
  reference           arrAdditionalColumn; // массив дополнительных колонок SpcStyleColumnParam
  reference           arrSection;          // массив разделов для спецификации SpcStyleSectionParam

  unsigned char       type;                // тип форматa листа бумаги 0- стандартный, 1 - пользовательский
  union {
    struct StandartSheet stPar;   // стандартный формат листа бумаги
    struct SheetSize     usPar;   // пользовательский формат листа бумаги
  };
};

//-------------------------------------------------------------------------------
// структура параметров стиля спецификации
// (Unicode)
// ---
struct SpcStyleParamW {
  wchar_t              layoutName1[MAX_TEXT_LENGTH];  // имя файла библиотеки оформлений для первого листа
  wchar_t              layoutName2[MAX_TEXT_LENGTH];  // имя файла библиотеки оформлений для второго листа
  unsigned int         shtType1;                      // тип оформления в библиотеке для первого листа
  unsigned int         shtType2;                      // тип оформления для второго листа

  unsigned char        variant;             // вариант оформления спецификации  0-простая, 1-А, 2-Б, 3-В, 4-Г
  unsigned char        sectionOn;           // 1- включено деление на разделы, 0-не включено
  char                 rezerv[10];          // не используется

  SpcTuningStyleParamW tuning;              // умолчательные настройки, считанные с библиотеки спецификации

  reference            arrColumn;           // массив колонок для спецификации -умолчательные значения SpcStyleColumnParam
  reference            arrAdditionalColumn; // массив дополнительных колонок SpcStyleColumnParam
  reference            arrSection;          // массив разделов для спецификации SpcStyleSectionParam

  unsigned char        type;                // тип форматa листа бумаги 0- стандартный, 1 - пользовательский
  union {
    struct StandartSheet stPar;   // стандартный формат листа бумаги
    struct SheetSize     usPar;   // пользовательский формат листа бумаги
  };
};

#ifdef _UNICODE
#define SpcStyleParamT  SpcStyleParamW
#else
#define SpcStyleParamT  SpcStyleParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// структура параметров описания спецификации
// ---
struct SpcDescrParam {
  char         layoutName[MAX_TEXT_LENGTH]; // имя файла библиотеки стилей
  unsigned int styleId;                     // номер стиля в библиотеке
  char         spcName   [MAX_TEXT_LENGTH]; // имя подключенного файла СП
};

//-------------------------------------------------------------------------------
// структура параметров описания спецификации
// (Unicode)
// ---
struct SpcDescrParamW {
  wchar_t      layoutName[MAX_TEXT_LENGTH]; // имя файла библиотеки стилей
  unsigned int styleId;                     // номер стиля в библиотеке
  wchar_t      spcName   [MAX_TEXT_LENGTH]; // имя подключенного файла СП
};

#ifdef _UNICODE
#define SpcDescrParamT  SpcDescrParamW
#else
#define SpcDescrParamT  SpcDescrParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// структура параметров интервала квалитета
// ---
struct QualityItemParam {
  short  minLimit;     // минимальное значение в интервале размеров
  short  maxLimit;     // максимальное значение в интервале размеров
  double high;         // верхнее отклонение
  double low;          // нижнее отклонение
};

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> LtQualSystem - система квалитета
// см. <ldefin2d.h> LtQualDir - квалитеты
// структура параметров квалитета
// ---
struct QualityContensParam {
	LtQualSystem systemQuality;         // система квалитета
  LtQualDir    kindQuality;           // тип квалитета
  char         name[MAX_TEXT_LENGTH]; // поле допуска
  reference    pQualityItems;         // массив интервалов
};

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> LtQualSystem - система квалитета
// см. <ldefin2d.h> LtQualDir - квалитеты
// структура параметров квалитета
// (Unicode)
// ---
struct QualityContensParamW {
	LtQualSystem systemQuality;         // система квалитета
  LtQualDir    kindQuality;           // тип квалитета
  wchar_t      name[MAX_TEXT_LENGTH]; // поле допуска
  reference    pQualityItems;         // массив интервалов
};

#ifdef _UNICODE
#define QualityContensParamT  QualityContensParamW
#else
#define QualityContensParamT  QualityContensParam
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> LtVariantType - типы данных для LtVariant
// структура для хранения данных некоторого типа
// ---
struct LtVariant {
	LtVariantType vType;              // тип хранимого данного
  short 				colVisible;         // для СП 1 - видимая колонка, 0 - невидимая
  short 				sortKey;            // ключ сортировки для колонки СП, 0 - сортировки нет
  short 				wReserved3;         // резерв
  union {
    char          chVal;                   // символ              ltv_Char    1
    unsigned char ucVal;                   // байт                ltv_UChar   2
    int           iVal;                    // целое               ltv_Int     3
    unsigned int  uiVal;                   // беззнаковое целое   ltv_UInt    4
    long          lVal;                    // длинное целое       ltv_Long    5
    float         fVal;                    // вещественное        ltv_Float   6
    double        dVal;                    // двойное             ltv_Double  7
  	char          strVal[MAX_TEXT_LENGTH]; // строка              ltv_Str     8
    short         shVal;                   // короткое целое      ltv_Short   10
  };
};

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> LtVariantType - типы данных для LtVariant
// структура для хранения данных некоторого типа
// (Unicode)
// ---
struct LtVariantEx {
	LtVariantType vType;              // тип хранимого данного
  short 				colVisible;         // для СП 1 - видимая колонка, 0 - невидимая
  short 				sortKey;            // ключ сортировки для колонки СП, 0 - сортировки нет
  short 				wReserved3;         // резерв
  union {
    char          chVal;                    // символ              ltv_Char    1
    unsigned char ucVal;                    // байт                ltv_UChar   2
    int           iVal;                     // целое               ltv_Int     3
    unsigned int  uiVal;                    // беззнаковое целое   ltv_UInt    4
    long          lVal;                     // длинное целое       ltv_Long    5
    float         fVal;                     // вещественное        ltv_Float   6
    double        dVal;                     // двойное             ltv_Double  7
    char          strVal[MAX_TEXT_LENGTH];  // строка              ltv_Str     8
    short         shVal;                    // короткое целое      ltv_Short   10
    wchar_t       wstrVal[MAX_TEXT_LENGTH]; // строка              ltv_WStr    11
  };
};


//-------------------------------------------------------------------------------
// структура параметров линии штриховки
// ---
struct HatchLineParam {
  double        x, y;          // точка привязки
  double        dx, dy;        // смещение для следующей линии. dy должен быть отличен от нуля!
  double        ang;           // угол наклона
  unsigned char typeCurvStyle; // 0 - системная(style), 1 - пользовательская(curPar)
  union {
  	unsigned short  style;     // стиль линии (1-11)
    CurveStyleParam curPar;    // пользовательский стиль линии, pattern для прерывистой кривой использует CurvePattern
  };
};

//-------------------------------------------------------------------------------
// структура параметров линии штриховки
// (Unicode)
// ---
struct HatchLineParamW {
  double        x, y;          // точка привязки
  double        dx, dy;        // смещение для следующей линии. dy должен быть отличен от нуля!
  double        ang;           // угол наклона
  unsigned char typeCurvStyle; // 0 - системная(style), 1 - пользовательская(curPar)
  union {
  	unsigned short   style;    // стиль линии (1-11)
    CurveStyleParamW curPar;   // пользовательский стиль линии, pattern для прерывистой кривой использует CurvePattern
  };
};

#ifdef _UNICODE
#define HatchLineParamT  HatchLineParamW
#else
#define HatchLineParamT  HatchLineParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// структура параметров стиля штриховки
// ---
struct HatchStyleParam {
 	char           name[TEXT_LENGTH]; // имя стиля
  double         step;              // шаг
  double         ang;               // угол наклона
  MathPointParam refPoint;          // базовая точка
  double         width;             // ширина
  unsigned long  color;             // цвет, по умолчанию FREE_COLOR (0xff000000l)
  unsigned char  mayChangeAngle;    // можно ли менять угол наклона
  unsigned char  mayChangeWidth;    // можно ли менять полосу штрихования
  unsigned char  mayChangeSpace;    // можно ли менять шаг/масштаб
  unsigned char  isScalable;        // работать по масштабу(1) или шагу(0)
  reference      arrLineParam;      // массив структур настроек линий, участвующих в штриховке HatchLineParam
};

//-------------------------------------------------------------------------------
// структура параметров стиля штриховки
// (Unicode)
// ---
struct HatchStyleParamW {
 	wchar_t        name[TEXT_LENGTH]; // имя стиля
  double         step;              // шаг
  double         ang;               // угол наклона
  MathPointParam refPoint;          // базовая точка
  double         width;             // ширина
  unsigned long  color;             // цвет, по умолчанию FREE_COLOR (0xff000000l)
  unsigned char  mayChangeAngle;    // можно ли менять угол наклона
  unsigned char  mayChangeWidth;    // можно ли менять полосу штрихования
  unsigned char  mayChangeSpace;    // можно ли менять шаг/масштаб
  unsigned char  isScalable;        // работать по масштабу(1) или шагу(0)
  reference      arrLineParam;      // массив структур настроек линий, участвующих в штриховке HatchLineParam
};

#ifdef _UNICODE
#define HatchStyleParamT  HatchStyleParamW
#else
#define HatchStyleParamT  HatchStyleParam
#endif // !_UNICODE

// см. <ldefin2d.h> определения для конвертации в растровый формат
// FORMAT_BMP ...
// см. <ldefin2d.h> определения для настройки цвета растрового формата
// BLACKWHITE ...
// см. <ldefin2d.h> орределения бит на пиксел для конвертации в растровый формат
// BPP_COLOR_01 ...
//-----------------------------------------------------------------------------
// структура параметров для конвертации в растровый формат
// ---
struct RasterFormatParam {
  unsigned char          format;                 // Формат растра FORMAT_BMP...FORMAT_PCX
  unsigned char          colorBPP;               // глубина цвета (бит на пиксел) BPP_COLOR_01...BPP_COLOR_32
  unsigned char          greyScale;              // >0 оттенки серого
  int                    extResolution;          // разрешение экрана : 0 - текущее 
  double                 extScale;               // масштаб
  unsigned char          colorType;              // тип цвета BLACKWHITE...COLOROBJECT
  unsigned char          onlyThinLine;           // >0 - только тонкими линиями
	char                   pages[MAX_TEXT_LENGTH]; // список диапазонов выводимых листов  "beg1-end1, beg2-end2, beg3-end3,  ..."
  unsigned char          rangeIndex;             // 0 - все,  1- нечетные 2- четные,                                     
  unsigned char          multiPageOutput;        // >0 сохранять все листы в оном файле (используется для FORMAT_TIF)
};

// см. <ldefin2d.h> определения для конвертации в растровый формат
// FORMAT_BMP ...
// см. <ldefin2d.h> определения для настройки цвета растрового формата
// BLACKWHITE ...
// см. <ldefin2d.h> орределения бит на пиксел для конвертации в растровый формат
// BPP_COLOR_01 ...
//-----------------------------------------------------------------------------
// структура параметров для конвертации в растровый формат
// (Unicode)
// ---
struct RasterFormatParamW {
  unsigned char          format;                 // Формат растра FORMAT_BMP...FORMAT_PCX
  unsigned char          colorBPP;               // глубина цвета (бит на пиксел) BPP_COLOR_01...BPP_COLOR_32
  unsigned char          greyScale;              // >0 оттенки серого
  int                    extResolution;          // разрешение экрана : 0 - текущее 
  double                 extScale;               // масштаб
  unsigned char          colorType;              // тип цвета BLACKWHITE...COLOROBJECT
  unsigned char          onlyThinLine;           // >0 - только тонкими линиями
	wchar_t                pages[MAX_TEXT_LENGTH]; // список диапазонов выводимых листов  "beg1-end1, beg2-end2, beg3-end3,  ..."
  unsigned char          rangeIndex;             // 0 - все,  1- нечетные 2- четные,                                     
  unsigned char          multiPageOutput;        // >0 сохранять все листы в оном файле (используется для FORMAT_TIF)
};

#ifdef _UNICODE
#define RasterFormatParamT  RasterFormatParamW
#else
#define RasterFormatParamT  RasterFormatParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// см. <ldefin2d.h> LtNodeType - перечисление возможных типов узла дерева библиотеки документов
// структура параметров узла дерева
// ---
struct TreeNodeParam {
  long          type;                  // тип узла: корень, директория, файл (из LtNodeType)
  char          name[MAX_TEXT_LENGTH]; // имя узла
  reference     comment;               // комментарий - динамический массив CHAR_STR_ARR - динамический массив строк символов
  reference     nodes;                 // динамический массив узлов  TreeNodeParam
};

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> LtNodeType - перечисление возможных типов узла дерева библиотеки документов
// структура параметров узла дерева
// (Unicode)
// ---
struct TreeNodeParamW {
  long          type;                  // тип узла: корень, директория, файл (из LtNodeType)
  wchar_t       name[MAX_TEXT_LENGTH]; // имя узла
  reference     comment;               // комментарий - динамический массив CHAR_STR_ARR_W - динамический массив строк символов
  reference     nodes;                 // динамический массив узлов  TreeNodeParam
};

#ifdef _UNICODE
#define TreeNodeParamT  TreeNodeParamW
#else
#define TreeNodeParamT  TreeNodeParam
#endif // !_UNICODE



//-------------------------------------------------------------------------------
// Параметры цвета фона
// ---
struct ViewColorParam {
  long                   color;        // цвет фона, или -1 если используется цвет окна, установленный в Windows
  unsigned char          useGradient;  // 1 - использовать градиентный переход при полутоновом отображении
                                       // 0 - не использовать. (доступно только для 3D-документов)
  long                   topColor;     // Верхний цвет перехода (доступно только для 3D-документов)
  long                   bottomColor;  // Нижний цвет перехода (доступно только для 3D-документов)
};

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> LtViewType - Типы видов
// Структура параметров ассоциативного вида
// ---
struct AssociationViewParam {
  ViewParam      viewPar;                      //параметры обычного вида

  char           fileName[MAX_TEXT_LENGTH];    // имя файла 3d документа
  char           projectionName[TEXT_LENGTH];  // имя проекции ( из списка проекций в документе источнике )

  unsigned char  viewType;                     // тип вида из LtViewType (readOnly)
  unsigned char  dimensionLayoutScaling;       // признак масштабирования аннатационных объектов вида (только для SetObjParam)

  unsigned char  projectionLink;               // проекционная связь
  unsigned char  disassembly;                  // разнести

  long           visibleLinesStyle;            // номер стиля отрисовки видимых ребер и очерков, если 0 - умолчательный стиль
  long           hiddenLinesStyle;             // номер стиля отрисовки всех невидимых линий, если 0 - умолчательный стиль  
  long           tangentEdgesStyle;            // номер стиля отрисовки видимых линий перехода, если 0 - умолчательный стиль  
  unsigned char  hiddenLinesShow;              // флаг отрисовки невидимых линий
  unsigned char  tangentEdgesShow;             // флаг отрисовки видимых линий перехода

  unsigned char  projBodies;                   // проецировать ли тела
  unsigned char  projSurfaces;                 // проецировать ли поверхности
  unsigned char  projThreads;                  // проецировать ли резьбы

  unsigned char  reserve[30];                  // резерв
  HatchParamEx   hatchPar;                     // параметры штриховки, используется только в виде разреза\сечения
  unsigned char  sameHatch;                    // oдинаковая штриховка всех деталей сборки
  unsigned char  section;                      // признак разрез/сечение 
};

//-------------------------------------------------------------------------------
// см. <ldefin2d.h> LtViewType - Типы видов
// Структура параметров ассоциативного вида
// (Unicode)
// ---
struct AssociationViewParamW {
  ViewParamW     viewPar;                      //параметры обычного вида

  wchar_t        fileName[MAX_TEXT_LENGTH];    // имя файла 3d документа
  wchar_t        projectionName[TEXT_LENGTH];  // имя проекции ( из списка проекций в документе источнике )

  unsigned char  viewType;                     // тип вида из LtViewType (readOnly)
  unsigned char  dimensionLayoutScaling;       // признак масштабирования аннатационных объектов вида (только для SetObjParam)

  unsigned char  projectionLink;               // проекционная связь
  unsigned char  disassembly;                  // разнести

  long           visibleLinesStyle;            // номер стиля отрисовки видимых ребер и очерков, если 0 - умолчательный стиль
  long           hiddenLinesStyle;             // номер стиля отрисовки всех невидимых линий, если 0 - умолчательный стиль  
  long           tangentEdgesStyle;            // номер стиля отрисовки видимых линий перехода, если 0 - умолчательный стиль  
  unsigned char  hiddenLinesShow;              // флаг отрисовки невидимых линий
  unsigned char  tangentEdgesShow;             // флаг отрисовки видимых линий перехода

  unsigned char  projBodies;                   // проецировать ли тела
  unsigned char  projSurfaces;                 // проецировать ли поверхности
  unsigned char  projThreads;                  // проецировать ли резьбы
  
  unsigned char  reserve[30];                  // резерв
  HatchParamEx   hatchPar;                     // параметры штриховки, используется только в виде разреза\сечения
  unsigned char  sameHatch;                    // oдинаковая штриховка всех деталей сборки
  unsigned char  section;                      // признак разрез/сечение 
};

#ifdef _UNICODE
#define AssociationViewParamT  AssociationViewParamW
#else
#define AssociationViewParamT  AssociationViewParam
#endif // !_UNICODE

//-------------------------------------------------------------------------------
// Структура параметров текстового документа 
// ---
struct TextDocumentParam {
  unsigned char      regim;                     // 0 - видимый режим,
                                                // 1 - невидимый режим
  char               fileName[MAX_TEXT_LENGTH]; // имя  файла чертежа
  char               comment [TEXT_LENGTH];     // комментарий
  char               author  [TEXT_LENGTH];     // автор
  LibraryStyleParam  firstSheet;                // оформление первого листа( имя библиотеки стилей, номер стиля в библиотеке)
  LibraryStyleParam  evenSheet;                 // оформление четных листов( имя библиотеки стилей, номер стиля в библиотеке)
  LibraryStyleParam  oddSheet;                  // оформление нечетных листов( имя библиотеки стилей, номер стиля в библиотеке)
  reference          arrTitleSheet;             // динамический массив оформлений титульных листов  LIBRARY_STYLE_ARR
  reference          arrTailSheet;              // динамический массив оформлений листов заключительной части  LIBRARY_STYLE_ARR
  unsigned char      type;                      // тип документа из DocType (lt_DocTxtStandart или lt_DocTxtUser )
  union { 
    struct StandartSheet stPar;                 // параметры стандартного формата; multiply не используется
    struct SheetSize     usPar;                 // параметры не стандартного формата
  };
};

//-------------------------------------------------------------------------------
// Структура параметров текстового документа 
// (Unicode)
// ---
struct TextDocumentParamW {
  unsigned char       regim;                     // 0 - видимый режим,
                                                 // 1 - невидимый режим
  wchar_t             fileName [MAX_TEXT_LENGTH];// имя  файла чертежа
  wchar_t             comment  [TEXT_LENGTH];    // комментарий
  wchar_t             author   [TEXT_LENGTH];    // автор
  LibraryStyleParamW  firstSheet;                // оформление первого листа( имя библиотеки стилей, номер стиля в библиотеке)
  LibraryStyleParamW  evenSheet;                 // оформление четных листов( имя библиотеки стилей, номер стиля в библиотеке)
  LibraryStyleParamW  oddSheet;                  // оформление нечетных листов( имя библиотеки стилей, номер стиля в библиотеке)
  reference           arrTitleSheet;             // динамический массив оформлений титульных листов  LIBRARY_STYLE_ARR
  reference           arrTailSheet;              // динамический массив оформлений листов заключительной части  LIBRARY_STYLE_ARR
  unsigned char       type;                      // тип документа из DocType (lt_DocTxtStandart или lt_DocTxtUser )
  union { 
    struct StandartSheet stPar;                  // параметры стандартного формата; multiply не используется
    struct SheetSize     usPar;                  // параметры не стандартного формата
  };
};

#ifdef _UNICODE
#define TextDocumentParamT  TextDocumentParamW
#else
#define TextDocumentParamT  TextDocumentParam
#endif // !_UNICODE


//-------------------------------------------------------------------------------
// Параметры осевой линии
// ---
struct AxisLineParam {
  MathPointParam begPoint; // координаты начальной точки осевой линии
  MathPointParam endPoint; // координаты конечной точки осевой линии
};

//-------------------------------------------------------------------------------
// Параметры объекта "Выносной элемент"
// ---
struct RemoteElementParam {
  unsigned short      style;      // стиль текста, если 0 - умолчательный стиль,
                                  // если style = INDICATIN_TEXT_LINE_ARR -> pText- массив TEXT_LINE_ARR
  long                signType;   // тип значка LtRemoteElmSignType
  double              x;          // координаты центра выносного элемента
  double              y;
  double              width;      // ширина (для прямоугольника и скругленного прямоугольника)
  double              height;     // высота (для прямоугольника и скругленного прямоугольника)
  double              smooth;     // радиус скругления прямоугольника
  double              radius;     // радиус окружности (для окружности)
  double              shelfX;     // координаты начала полки
  double              shelfY;
  int                 shelfDir;   // направление полки по X (1 -вправо -1-влево, 2- полка направлена в вверх 3- полка направлена вниз)
  reference           pText;      // если style = INDICATIN_TEXT_LINE_ARR , TEXT_LINE_ARR - динамический массив строк текста
                                  // CHAR_STR_ARR или CHAR_STR_ARR_W - динамический массив строк символов текста шероховатости
};

//-----------------------------------------------------------------------------
// Структура параметров для копирования объекта 2d документа
// ---
struct CopyObjectParam {
  reference p;                    // указатель на объект, группу, вид, слой
  double xOld;                    // базовая точка объекта
  double yOld;
  double xNew;                    // в какую точку копировать
  double yNew;
  double scale;                   // масштаб
  double angle;                   // угол поворота в градусах
  unsigned char attrCopy;         // копировать ли атрибуты
  unsigned char dimLineScale;     // выносные линии масштабировать
  unsigned char spcObjCopy;       // копировать объекты спецификации
  unsigned char storagesCopy;     // копировать пользовательские данные и свойства
  unsigned char hyperLinksCopy;   // копировать ссылки
  unsigned char reserv[7];        // резерв - не используется
};

//-----------------------------------------------------------------------------
// структура параметров для осуществления подписки \ отписки сообщений в COM
// ---
struct NotifyConnectionParam {
  reference pContainer; // указатель на объект Компас, контейнер сообщений. 
                        // Для приложения 0. Для документа указатель документа. 
  long      objType;    // Дополнительный параметр. Либо тип объекта, 
                        // либо указатель на объект(для ksObject2DNotify).
  int       ifType;     // тип интерфейсов сообщений ksNotifyType
  LPUNKNOWN iContainer; // указатель на объект Компас, контейнер сообщений. 
  LPUNKNOWN iObj;       // Дополнительный параметр. Указатель на объект(для ksObject3DNotify).
                        // если указатель задан, то objType не используется.
};


#pragma pack(pop)
#endif

