////////////////////////////////////////////////////////////////////////////////
//
// Редактирование модели LT_Edit.h
//
////////////////////////////////////////////////////////////////////////////////
#ifndef __LT_EDIT_H
#define __LT_EDIT_H

#ifndef __LTDEFINE_H
#include "ltdefine.h"
#endif

#ifndef __LIB_FUNC__
#define __LIB_FUNC__
#define LIB_FUNC WINAPI
#endif

interface IParametrizationParam;

extern "C" {

// Экспортный номер - 23
//-----------------------------------------------------------------------------
// Сохранить в макроэлемент с указателем ref параметры редактирования:
// имя файла библиотеки, имя библиотеки и номер функции, предназначенной
// для редактирования данного макроэлемента.
// Можно сохранить в макроэлементе дополнительные параметры, распределив блок
// памяти userPars и заполнив его нужными значениями (допустимы все типы данных,
// кроме указателей).
// Параметр size - размер буфера userPars.
// При значениях параметров fileName=0, libName=0, number=-1 в макроэлементе
// сохраняется в качестве редактирующей та функция, которая вызвала SetMacroParam.
// Возвращается 1 в случае успеха, 0 в случае неудачи.
//-----------------------------------------------------------------------------
int     LIB_FUNC  SetMacroParam( reference    ref,       // указатель на макроэлемент
																 void        *userPars,  // указатель на буфер дополнительных параметров
																 unsigned int size,      // размер буфера дополнительных параметров
																 char        *fileName,  // имя файла библиотеки, в которой находтся функция редактирования
																 char        *libName,   // имя библиотеки, в которой находтся функция редактирования
																 int          number  ); // номер функции редактирования



// Экспортный номер - 271
//--------------------------------------------------------------------------
//  Функция устанавливает параметры редактирования макроэлемента
//  имя файла библиотеки, имя библиотеки, номер функции в библиотеке,
//  которая отвечает за редактирование макроэлемента
//  value - память длиной   size, в которой записаны  значения параметров
//  макроэлемента  все кроме указателей
//  возвращает 1- успех   0- не успех
//  paramType - битовый флаг, указание какой тип редактирования поддерживает макро
//  #define MP_DBL_CLICK_OFF  0x01 //>0 редактирование по двойному нажанию выключено
//  #define MP_HOTPOINTS      0x02 //>0 интерфейс hot точек включен
//  #define MP_EXTERN_EDIT    0x04 //>0 интерфейс внешнего управления
//--------------------------------------------------------------------------
extern "C" int LIB_FUNC ksSetMacroParam( reference    ref,       // указатель на макроэлемент
																         void        *userPars,  // указатель на буфер дополнительных параметров
																         unsigned int size,      // размер буфера дополнительных параметров
																         char        *fileName,  // имя файла библиотеки, в которой находтся функция редактирования
																         char        *libName,   // имя библиотеки, в которой находтся функция редактирования
																         int          number,   // номер функции редактирования
                                         unsigned char paramType ); //тип редактирования, которое поддерживает макро


// Экспортный номер - 859
//--------------------------------------------------------------------------
//  Функция устанавливает параметры редактирования макроэлемента
//  имя файла библиотеки, имя библиотеки, номер функции в библиотеке,
//  которая отвечает за редактирование макроэлемента
//  value - память длиной   size, в которой записаны  значения параметров
//  макроэлемента  все кроме указателей
//  возвращает 1- успех   0- не успех
//  paramType - битовый флаг, указание какой тип редактирования поддерживает макро
//  #define MP_DBL_CLICK_OFF  0x01 //>0 редактирование по двойному нажанию выключено
//  #define MP_HOTPOINTS      0x02 //>0 интерфейс hot точек включен
//  #define MP_EXTERN_EDIT    0x04 //>0 интерфейс внешнего управления
//  (Unicode)
//--------------------------------------------------------------------------
extern "C" int LIB_FUNC ksSetMacroParamW( reference     ref,       // указатель на макроэлемент
																          void         *userPars,  // указатель на буфер дополнительных параметров
																          unsigned int  size,      // размер буфера дополнительных параметров
																          LPWSTR        fileName,  // имя файла библиотеки, в которой находтся функция редактирования
																          LPWSTR        libName,   // имя библиотеки, в которой находтся функция редактирования
																          int           number,   // номер функции редактирования
                                          unsigned char paramType ); //тип редактирования, которое поддерживает макро


#ifdef _UNICODE
#define ksSetMacroParamT  ksSetMacroParamW
#else
#define ksSetMacroParamT  ksSetMacroParam
#endif // !UNICODE


// Экспортный номер - 22
//-----------------------------------------------------------------------------
// Выдать запомненные ранее (функцией SetMacroParam) дополнительные параметры
// редактирования для макроэлемента c указателем ref.
// При ref=0 выдаются параметры макроэлемента, редактирование которого производится
// в данный момент (если таковой имеется).
// Должен быть распределен участок памяти userPars размером size, совпадающим
// с аналогичным параметром функции SetMacroParam.
// Возвращается 1 в случае успеха, 0 в случае неудачи.
//-----------------------------------------------------------------------------
int     LIB_FUNC  GetMacroParam( reference    ref,      // указатель на макроэлемент
                                 void        *userPars, // указатель на буфер дополнительных параметров
																 unsigned int size );   // размер буфера дополнительных параметров

// Экспортный номер - 262
//------------------------------------------------------------------------------
// Получить для макроэлемента c указателем ref параметры редактирования:
// имя файла библиотеки, имя библиотеки и номер функции, предназначенной
// для редактирования данного макроэлемента.
// При ref=0 выдаются параметры для макроэлемента, редактирование которого
// производится в данный момент (если таковой имеется).
// При значении NULL параметров fileName, libName, number или если значение
// fileNameSize, libNameSize меньше требуемой длины - параметр не заполняется.
// Возвращается 1 в случае успеха, 0 в случае неудачи.
// ---
int     LIB_FUNC  ksGetMacroEditParam( reference    ref,          // указатель на макроэлемент
                                       char*        fileName,     // указатель на буфер имени файла библиотеки
                                       unsigned int fileNameSize, // размер буферa имени файла библиотеки
                                       char*        libName,      // указатель на буфер имени библиотеки
                                       unsigned int libNameSize,  // размер буферa имени библиотеки
                                       int*         number );     // указатель на буфер номерa функции редактирования

// Экспортный номер - 860
//------------------------------------------------------------------------------
// Получить для макроэлемента c указателем ref параметры редактирования:
// имя файла библиотеки, имя библиотеки и номер функции, предназначенной
// для редактирования данного макроэлемента.
// При ref=0 выдаются параметры для макроэлемента, редактирование которого
// производится в данный момент (если таковой имеется).
// При значении NULL параметров fileName, libName, number или если значение
// fileNameSize, libNameSize меньше требуемой длины - параметр не заполняется.
// Возвращается 1 в случае успеха, 0 в случае неудачи. (Unicode)
// ---
int     LIB_FUNC  ksGetMacroEditParamW( reference    ref,          // указатель на макроэлемент
                                        LPWSTR       fileName,     // указатель на буфер имени файла библиотеки
                                        unsigned int fileNameSize, // размер буферa имени файла библиотеки
                                        LPWSTR       libName,      // указатель на буфер имени библиотеки
                                        unsigned int libNameSize,  // размер буферa имени библиотеки
                                        int*         number );     // указатель на буфер номерa функции редактирования


#ifdef _UNICODE
#define ksGetMacroEditParamT  ksGetMacroEditParamW
#else
#define ksGetMacroEditParamT  ksGetMacroEditParam
#endif // !UNICODE


// Экспортный номер - 250
//------------------------------------------------------------------------------
// Получить размер памати параметров макроэлемента  c указателем ref.
// При ref=0 выдаются параметры макроэлемента, редактирование которого производится
// в данный момент (если таковой имеется).
// ---
int     LIB_FUNC  GetMacroParamSize( reference ref );

// Экспортный номер - 24
//--------------------------------------------------------------------------
//  возвращает указатель на редактируемый маско- если режим редактирования макроэлемента
//  0- режим создания макроэлемента
//--------------------------------------------------------------------------
reference LIB_FUNC  EditMacroMode();


// Экспортный номер - 197
//---------------------------------------------------------------------------
// Добавить объект, слой, вид или группу объектов в макрообъект.
// ( слой и вид будут  добавлены россыпью )
// Добавляемые объекты и макрообъект должны принадлежать текущему документу и одному виду.
// Добавляемые объекты  перестают быть самостоятельными
// Функция возвращает 1 в случае успеха, 0 - в случае неудачи.
//---------------------------------------------------------------------------
int  LIB_FUNC ksAddObjectToMacro( reference macro, //указатель на макрообъект
                                  reference obj ); //указатель на добавляемый объект

// Экспортный номер - 275
//------------------------------------------------------------------------------
// очистить макрообъект с референсом macro ( удалить всю геометрию ),
// и если прислана группа gr, то добавить ее в макро
// Функция возвращает 1 в случае успеха, 0 - в случае неудачи.
// ---
int LIB_FUNC ksUpdateMacro( reference macro, reference gr );


// Экспортный номер - 25
//-----------------------------------------------------------------------------
// Удалить из модели объект с указателем ref (объект вида, вид, группу, слой).
// Возвращает 1 в случае успеха, 0 в случае неудачи.
//-----------------------------------------------------------------------------
int     LIB_FUNC  DeleteObj( reference ref );

// Экспортный номер - 26
//-----------------------------------------------------------------------------
// Сдвинуть объект с указателем ref (объект вида, вид, группу, слой).
// Вектор сдвига dx,dy - геометрический для текущего вида.
// Возвращает 1 в случае успеха, 0 в случае неудачи.
//-----------------------------------------------------------------------------
int     LIB_FUNC  MoveObj( reference ref,          // указатель на объект
                           double dx, double dy ); // вектор сдвига


// Экспортный номер - 27
//-----------------------------------------------------------------------------
// Повернуть объект с указателем ref (объект вида, вид, группу, слой)
// вокруг точки с координатами x,y (геометрические для текущего вида).
// Возвращает 1 в случае успеха, 0 в случае неудачи.
//-----------------------------------------------------------------------------
int     LIB_FUNC  RotateObj( reference ref,      // указатель на объект
														 double x, double y, // центр поворота
														 double angle );     // угол поворота в градусах

// Экспортный номер - 28
//-----------------------------------------------------------------------------
// Преобразовать объект с указателем ref (объект вида, вид, группу, слой)
// по установленной матрице трансформации (см. функции Mtr и DeleteMtr ).
// Возвращает 1 в случае успеха, 0 в случае неудачи.
//-----------------------------------------------------------------------------
int     LIB_FUNC  TransformObj( reference ref );


// Экспортный номер - 29
//-----------------------------------------------------------------------------
// Включить (light=1) или выключить (light=0) подсветку для объекта
// с указателем ref (объект вида, вид, группа, слой).
// Возвращает 1 в случае успеха, 0 в случае неудачи.
//-----------------------------------------------------------------------------
int     LIB_FUNC  LightObj( reference ref,         // указатель на объект
														unsigned char light ); // режим подсветки


// Экспортный номер - 156
//-----------------------------------------------------------------------------
// Симметрично отобразить (copy=0) объект с указателем ref (объект вида, вид,
// группу, слой) относительно оси или создать симметричную копию объекта (copy=1).
// Ось задается в геометрических координатах текущего вида.
// Возвращает 1 в случае успеха, 0 в случае неудачи.
//-----------------------------------------------------------------------------
int     LIB_FUNC  SymmetryObj( reference ref,         // указатель на объект
                               double x1, double y1,  // первая точка оси
                               double x2, double y2,  // вторая точка оси
                               unsigned char copy  ); // режим копирования

// Экспортный номер - 217
//--------------------------------------------------------------------------
// Симметрично отобразить (copy=0) объект с указателем ref (объект вида, вид,
// группу, слой) относительно оси или создать симметричную копию объекта (copy=1).
// Ось задается в геометрических координатах текущего вида.
// возвращает указатель на объект или группу объектов в случае успеха,
// 0 в случае неудачи.
//--------------------------------------------------------------------------
reference LIB_FUNC ksSymmetryObj( reference ref,         // указатель на объект
                                  double x1, double y1,  // первая точка оси
                                  double x2, double y2,  // вторая точка оси
                                  unsigned char copy  ); // режим копирования

// Экспортный номер - 157
//-----------------------------------------------------------------------------
// Копировать объект с указателем ref (объект вида, вид, группу, слой) в новую
// точку с возможностью задания для копии масштабирования и поворота вокруг
// базовой точки.
// Точки задаются в геометрических координатах текущего вида.
// Возвращает 1 в случае успеха, 0 в случае неудачи.
//-----------------------------------------------------------------------------
int     LIB_FUNC  CopyObj( reference ref,                // указатель на объект
                           double xOld,  double yOld,    // базовая точка объекта
                           double xNew,  double yNew,    // в какую точку копировать
                           double scale, double angle ); // масштаб и угол поворота в градусах

// Экспортный номер - 216
//--------------------------------------------------------------------------
// Копировать объект с указателем ref (объект вида, вид, группу, слой) в новую
// точку с возможностью задания для копии масштабирования и поворота вокруг
// базовой точки.
// Возвращает указатель на объект или группу объектов в случае успеха, 0
// в случае неудачи.
// Точки задаются в геометрических координатах текущего вида.
//--------------------------------------------------------------------------
reference LIB_FUNC ksCopyObj( reference ref,                // указатель на объект
                              double xOld,  double yOld,    // базовая точка объекта
                              double xNew,  double yNew,    // в какую точку копировать
                              double scale, double angle ); // масштаб и угол поворота в градусах

// Экспортный номер - 721
//--------------------------------------------------------------------------
// Копировать объект с указателем ref (объект вида, вид, группу, слой) в новую
// точку с возможностью задания для копии масштабирования и поворота вокруг
// базовой точки.
// Возвращает указатель на объект или группу объектов в случае успеха, 0
// в случае неудачи.
// Точки задаются в геометрических координатах текущего вида.
//--------------------------------------------------------------------------
reference LIB_FUNC ksCopyObjEx( CopyObjectParam * param  );

// Экспортный номер - 354
//-----------------------------------------------------------------------------
// Создать объект заданного типа, используя визуальный процесс создания объекта.
// Так как сиcтема может работать только с одним процессом, то нужно завершить
// другие процессные функции: Cursor, Placement, CommandWindow, ksEditViewObject.
// Возвращает указатель на созданный объект или 0.
// type выбирать из интервала   [LINESEG_OBJ ...MULTITEXTLEADER] (ltdefine.h)
//-----------------------------------------------------------------------------
reference LIB_FUNC  ksCreateViewObject( unsigned short type );


// Экспортный номер - 355
//-----------------------------------------------------------------------------
// Запустить визуальный процесс редактирования объекта с указателем ref.
// Так как сиcтема может работать только с одним процессом, то нужно завершить
// другие процессные функции: Cursor, Placement, CommandWindow, ksCreateViewObject.
// Возвращает 1 - объект отредактирован, 0 - нет.
//-----------------------------------------------------------------------------
int     LIB_FUNC  ksEditViewObject( reference ref );


// Экспортный номер - 304
//-----------------------------------------------------------------------------
// Заменить параметры объекта с указателем ref.
// parType в интервале [ALLPARAM ... DIM_VALUE] см. ltdefine.h
// Возвращает 1 в случае успеха, 0 в случае неудачи.
//-----------------------------------------------------------------------------
int     LIB_FUNC  SetObjParam( reference ref,   // указатель на объект
															 void *param,     // указатель на структуру параметров
															 int   parSize,   // размер структуры параметров
															 int   parType ); // какую составную часть параметров заменить


// Экспортный номер - 305
//-----------------------------------------------------------------------------
// Выдать параметры объекта с указателем ref.
// parType в интервале [ALLPARAM ... DIM_VALUE] см. ltdefine.h
// Возвращает тип объекта [LINESEG_OBJ ...ANNTEXT_OBJ] (ltdefine.h) в случае успеха,
// 0 в случае неудачи.
//-----------------------------------------------------------------------------
int     LIB_FUNC  GetObjParam( reference ref,   // указатель на  объект
															 void *param,     // указатель на структуру параметров
															 int   parSize,   // размер структуры параметров
															 int   parType ); // какую составную часть параметров выдать

// Экспортный номер - 325
//-----------------------------------------------------------------------------
// Получить параметры стиля  с идентификатором styleId.
// Для стиля кривой:    type=CURVE_STYLE   , param - указатель на структуру CurveStyleParam.
// Для стиля кривой:    type=CURVE_STYLE_EX, param - указатель на структуру CurveStyleParam.
// Для стиля текста:    type=TEXT_STYLE    , param - указатель на структуру TextStyleParam.
// Для стиля штриховки: type=HATCH_STYLE   , param - указатель на структуру HatchStyleParam.
// Функция возвращает 1 в случае успеха; 0 - стиль не найден, в этом случае
// структура param будет заполнена параметрами стиля по умолчанию.
//-----------------------------------------------------------------------------
int     LIB_FUNC  GetStyleParam( unsigned char  type,   // тип стиля
                                 unsigned short styleId,// идентификатор стиля
                                 void          *param,  // указатель на структуру параметров стиля
                                 unsigned int   size ); // размер структуры параметров


// Экспортный номер - 326
//-----------------------------------------------------------------------------
// Добавить в документ новый стиль кривой (type=CURVE_STYLE) или текста (type=TEXT_STYLE).
// В случае copy = 0 - создать новый стиль:
// Для стиля кривой: type=CURVE_STYLE   , param - указатель на структуру CurveStyleParam.
// Для стиля кривой: type=CURVE_STYLE_EX, param - указатель на структуру CurveStyleParam.
// Для стиля текста: type=TEXT_STYLE    , param - указатель на структуру TextStyleParam.
// Для стиля штриховки: type=HATCH_STYLE   , param - указатель на структуру HatchStyleParam.
// В случае copy = 1 - копировать стиль из библиотеки:
//   для стиля кривых и для стиля текста param - указатель на структуру LibStyle.
// Функция возвращает идентификатор стиля в случае успеха, 0 в случае неудачи.
//-----------------------------------------------------------------------------
unsigned short LIB_FUNC AddStyle( unsigned char type,  // тип стиля
                                  void         *param, // указатель на структуру параметров стиля
                                  unsigned int  size,  // размер структуры параметров
                                  unsigned char copy ); // 0 - создать вручную 1- создать из библиотеки

// Экспортный номер - 406
//-------------------------------------------------------------------------------------
// Проверить, есть ли стиль в текущем документе
// В случае copy = 0 - создать новый стиль:
// Для стиля кривой: type=CURVE_STYLE   , param - указатель на структуру CurveStyleParam.
// Для стиля кривой: type=CURVE_STYLE_EX, param - указатель на структуру CurveStyleParam.
// Для стиля текста: type=TEXT_STYLE    , param - указатель на структуру TextStyleParam.
// Для стиля штриховки: type=HATCH_STYLE   , param - указатель на структуру HatchStyleParam.
// В случае copy = 1 - копировать стиль из библиотеки:
//   для стиля кривых и для стиля текста param - указатель на структуру LibStyle.
// Функция возвращает 1, если стиль в документе есть, 0 - если нет
//-------------------------------------------------------------------------------------
int LIB_FUNC ksIsStyleInDocument( unsigned char  type,  // тип стиля
                                  void          *param, // указатель на структуру параметров стиля
                                  unsigned int   size,  // размер структуры параметров
                                  unsigned char  copy );// 0 - создать вручную 1- создать из библиотеки

// Экспортный номер - 407
//-------------------------------------------------------------------------------------
// Удалить стиль в текущем документе
// Для стиля кривой: type=CURVE_STYLE   , param - указатель на структуру CurveStyleParam.
// Для стиля кривой: type=CURVE_STYLE_EX, param - указатель на структуру CurveStyleParam.
// Для стиля текста: type=TEXT_STYLE    , param - указатель на структуру TextStyleParam.
// Для стиля штриховки: type=HATCH_STYLE   , param - указатель на структуру HatchStyleParam.
// В случае copy = 1 - копировать стиль из библиотеки:
//   для стиля кривых и для стиля текста param - указатель на структуру LibStyle.
// Функция возвращает 1, если стиль в документе удален, 0 - если нет
//-------------------------------------------------------------------------------------
int LIB_FUNC ksDeleteStyleFromDocument( unsigned char  type,  // тип стиля
                                        void          *param,   // указатель на структуру параметров стиля
                                        unsigned int   size,  // размер структуры параметров
                                        unsigned char  flag );// 0 - создать вручную 1- создать из библиотеки

// Экспортный номер - 371
//------------------------------------------------------------------------------
// Функция возвращает указатель на динамический массив LIBRARY_STYLE_ARR -
// массив стилей заданного типа, находящихся в заданной библиотеке стилей.
// В случае неудачи возвращает 0.
// libraryType в интервале [CURVE_STYLE_LIBRARY...SPC_LAYOUT_STYLE_LIBRARY]
// ---
reference LIB_FUNC ksGetLibraryStylesArray( char         *libraryName,   // полное имя библиотеки стилей
                                            unsigned char libraryType ); // тип библиотеки стиля

// Экспортный номер - 861
//------------------------------------------------------------------------------
// Функция возвращает указатель на динамический массив LIBRARY_STYLE_ARR -
// массив стилей заданного типа, находящихся в заданной библиотеке стилей.
// В случае неудачи возвращает 0.
// libraryType в интервале [CURVE_STYLE_LIBRARY...SPC_LAYOUT_STYLE_LIBRARY]
// ---
reference LIB_FUNC ksGetLibraryStylesArrayW( LPWSTR        libraryName,   // полное имя библиотеки стилей
                                             unsigned char libraryType ); // тип библиотеки стиля


#ifdef _UNICODE
#define ksGetLibraryStylesArrayT  ksGetLibraryStylesArrayW
#else
#define ksGetLibraryStylesArrayT  ksGetLibraryStylesArray
#endif // !UNICODE


// Экспортный номер - 30
//-----------------------------------------------------------------------------
// Проверить, существует ли объект с указателем ref.
// Функция возвращает 1 - объект существует, 0 - нет.
//-----------------------------------------------------------------------------
int     LIB_FUNC  ExistObj( reference ref );


// Экспортный номер - 31
//-----------------------------------------------------------------------------
// Найти объект, ближайший к заданной точке.
// limit - максимально допустимое расстояние до объекта.
// Функция возвращает указатель на найденный объект в случае успеха,
// 0 в случае неудачи.
//-----------------------------------------------------------------------------
reference LIB_FUNC  FindObj( double x, double y, // координаты точки
                             double limit );     // допустимое расстояние


// Экспортный номер - 154
//--------------------------------------------------------------------------
// Выдать габаритный прямоугольник объекта.
// Габаритнывй прямоугольник возвращается в координатах листа.
// Возвращается 1- в случае успеха, 0 в случае неудачи.
//--------------------------------------------------------------------------
int       LIB_FUNC  GetObjGabaritRect( reference p,     //указатель на объект
                                       RectParam *par); //размеры габаритного прямоугольника
// Экспортный номер - 161
//--------------------------------------------------------------------------
// пересчитать точку из CK текущего вида в CK листа
//--------------------------------------------------------------------------
int       LIB_FUNC  ViewToSheet( double x, double y,           //геометрическая точка
                                 double *outX, double *outY ); //листовая точка
// Экспортный номер - 162
//--------------------------------------------------------------------------
// пересчитать точку из CK листа в CK текущего вида
//--------------------------------------------------------------------------
int       LIB_FUNC  SheetToView( double x, double y,          //листовая точка
                                 double *outX, double *outY );//геометрическая точка

// Экспортный номер - 32
//--------------------------------------------------------------------------
//  Создать новую группу.
//  Возвращается указатель на группу.
//  В модельной группе лежат объекты, которые уже включены в модель документа.
//  Во временной группе могут лежать временные и модельные объекты.
//  Если для временной группы не будет вызвана функция StoreTmpGroup,
//  временные объекты группы будут уничтожены по окончании работы библиотеки.
//--------------------------------------------------------------------------
reference LIB_FUNC NewGroup( unsigned char _tmp );  //тип групы 0 - модельная 1 - временная группа

// Экспортный номер - 33
//--------------------------------------------------------------------------
//  Конец группы.
//  Объекты вида, виды, слои, если они вводились между
//  операторами NewGroup и EndGroup попадают в группу.
//  Если группа временная, объекты считаются временными.
//--------------------------------------------------------------------------
void      LIB_FUNC EndGroup();

// Экспортный номер - 34
//--------------------------------------------------------------------------
// Очистить группу  g.
// Если элементы временные -  удаляются. Если g = 0, очищается группа селектирования.
//--------------------------------------------------------------------------
int       LIB_FUNC ClearGroup( reference g );  //указатель на группу

// Экспортный номер - 263
//--------------------------------------------------------------------------
// Очистить группу  g. Если g = 0, очищается группа селектирования.
// deleteTmp = 1 -> временные элементы удаляются.
//--------------------------------------------------------------------------
int LIB_FUNC ksClearGroup( reference g, unsigned char deleteTmp );


// Экспортный номер - 35
//--------------------------------------------------------------------------
//  Исключить объект p из группы g.
//  Если объект временный - удаляется. Если g = 0, группа селектирования
//--------------------------------------------------------------------------
int       LIB_FUNC ExcludeObjGroup( reference g,   //указатель группы
																		reference p ); //указатель на исключаемый объект

// Экспортный номер - 36
//--------------------------------------------------------------------------
// Добавить объект p в группу g.  Если g = 0, группа селектирования
//--------------------------------------------------------------------------
int       LIB_FUNC AddObjGroup( reference g,      //указатель группы
																reference p );    //указатель на добавляемый объект

// Экспортный номер - 37
//--------------------------------------------------------------------------
// Поставить временную группу  g  в модель. Объекты из временной группы
// появляются в чертеже, группа становится постоянной.
//--------------------------------------------------------------------------
int       LIB_FUNC StoreTmpGroup( reference g );  //указатель группы


// Экспортный номер - 38
//--------------------------------------------------------------------------
// Сохранить группу g   с именем. Если g = 0, группа селектирования.
//--------------------------------------------------------------------------
int       LIB_FUNC SaveGroup( reference g,  //указатель группы
															char *name ); //имя сохраняемой группы


// Экспортный номер - 862
//--------------------------------------------------------------------------
// Сохранить группу g   с именем. Если g = 0, группа селектирования.
// (Unicode)
//--------------------------------------------------------------------------
int       LIB_FUNC SaveGroupW( reference g,  //указатель группы
															 LPWSTR name ); //имя сохраняемой группы


#ifdef _UNICODE
#define SaveGroupT  SaveGroupW
#else
#define SaveGroupT  SaveGroup
#endif // !UNICODE


// Экспортный номер - 39
//--------------------------------------------------------------------------
// Найти группу по имени. Возвращается указатель на группу.
//--------------------------------------------------------------------------
reference LIB_FUNC GetGroup( char *name );  //имя группы


// Экспортный номер - 863
//--------------------------------------------------------------------------
// Найти группу по имени. Возвращается указатель на группу.
//--------------------------------------------------------------------------
reference LIB_FUNC GetGroupW( LPWSTR name );  //имя группы

#ifdef _UNICODE
#define GetGroupT  GetGroupW
#else
#define GetGroupT  GetGroup
#endif // !UNICODE


// Экспортный номер - 40
//--------------------------------------------------------------------------
// Селектировать объекты в группу g.
// selectMode=1 - полностью внутри;
// selectMode=2 - снаружи;
// selectMode=3 - секущее окно;
// Координаты - геометрические в СК текущего вида.
//--------------------------------------------------------------------------
int       LIB_FUNC SelectGroup( reference g,               //указатель группы
																unsigned char selectMode,  //тип селектирования
																double xmin, double ymin,  // вершина прямоугольника-ловушки
																double xmax, double ymax );// вершина прямоугольника-ловушки
// Экспортный номер - 41
//---------------------------------------------------------------------------
// Определить есть ли в группе  с указателем g объекты.
// 1- объекты есть 0- нет. Если g = 0, группа селектирования
//---------------------------------------------------------------------------
int        LIB_FUNC ExistGroupObj( reference g );

// Экспортный номер - 239
//------------------------------------------------------------------------------
// Положить группу в clip с удалением или копированием геометрии из документа источника
// возвращает 1 в случае успеха  или 0 в случае неудачи
// ---
int LIB_FUNC ksWriteGroupToClip( reference g,         // указатель на группу
                                 unsigned char copy ); // 1 - с копированием; 0 - с удалением из текущего документа

// Экспортный номер - 240
//------------------------------------------------------------------------------
// Прочитать геометрию из clip и положить ее во временную группу.
// Геометрия должна принадлежать одному виду. Параметризация при чтении из clip теряется,
// атрибуты сохраняются.
// возвращает указатель на группу в случае успеха  или 0 в случае неудачи
// ---
reference LIB_FUNC ksReadGroupFromClip();

// Экспортный номер - 249
//////////////////////////////////////////////////////////////////////////
// Получить имя группы по указателю на группу
// Функция возвращает 0 - ошибка указания группы
//                    1 - именная группа ( имя есть )
//                    2 - рабочая группа ( имени нет )
//                   -1 - именная группа ( размер size меньше требуемой длины имени группы, имя не передается )
//---
int LIB_FUNC ksGetGroupName( reference gr,             // указатель на группу
                             char *name, int size );   // указатель строки для имени группы и размер строки

// Экспортный номер - 864
//------------------------------------------------------------------------------
// Получить имя группы по указателю на группу
// Функция возвращает 0 - ошибка указания группы
//                    1 - именная группа ( имя есть )
//                    2 - рабочая группа ( имени нет )
//                   -1 - именная группа ( размер size меньше требуемой длины имени группы, имя не передается )
// (Unicode)
//---
int LIB_FUNC ksGetGroupNameW( reference gr,             // указатель на группу
                              LPWSTR name, int size );   // указатель строки для имени группы и размер строки


#ifdef _UNICODE
#define ksGetGroupNameT  ksGetGroupNameW
#else
#define ksGetGroupNameT  ksGetGroupName
#endif // !UNICODE


// Экспортный номер - 285
//------------------------------------------------------------------------------
// Разрушить присланные не только составные объекты ( макроэлементы, вставки фрагментов,
// эквидистанты, прямоугольники, контуры ) но и виды (если у них есть
// связь с 3Д-моделью)
// Возвращает 1 в случае успеха и 0 в случае неудачи
// ---
long  LIB_FUNC ksDestroyObjects( reference p );  //указатель на объект, вид, слой или группу

// Экспортный номер - 59
//---------------------------------------------------------------------------
//  Ввод матрицы трансформации.
//  Допускается вложение матриц трансформации. В результате будет
//  действовать суммарная матрица, полученная произведением накопленных матриц.
//  Объкты вида, вводимые между операторами Mtr и DeleteMtr, подвергаются
//  преобразованию по суммарной матрице.
//---------------------------------------------------------------------------
int       LIB_FUNC Mtr( double x, double y, //начало локальной системы координат
												double angle,       //угол наклона системы координат в гр.
												double scale );     //масштаб локальной системы координат

// Экспортный номер - 248
//---------------------------------------------------------------------------
//  Ввод матрицы трансформации.
//  Допускается вложение матриц трансформации. В результате будет
//  действовать суммарная матрица, полученная произведением накопленных матриц.
//  Объкты вида, вводимые между операторами ksMtr и DeleteMtr, подвергаются
//  преобразованию по суммарной матрице.
//---------------------------------------------------------------------------
int       LIB_FUNC ksMtr( double x, double y,   //начало локальной системы координат
												  double angle,         //угол наклона системы координат в гр.
												  double scaleX,        //масштаб локальной системы координат по оси Х
												  double scaleY );      //масштаб локальной системы координат по оси Y

// Экспортный номер - 160
//---------------------------------------------------------------------------
//  Ввод матрицы трансформации  по матрице поворота rotateMtr и
//  вектору сдвига  moveArr
//  Объкты вида, вводимые между операторами MtrForIGES и DeleteMtr, подвергаются
//  трансформации по суммарной матрице.
//---------------------------------------------------------------------------
int       LIB_FUNC MtrForIGES( double rotateMtr[2][2],  double moveArr[2] );

// Экспортный номер - 60
//---------------------------------------------------------------------------
//  Выключение матрицы трансформации.
//---------------------------------------------------------------------------
int       LIB_FUNC DeleteMtr();


// Экспортный номер - 100
//----------------------------------------------------------------------
// Cоздать итератор для хождения по модели.
// Для хождения по документам, видам, группам, слоям - parent не нужен(0).
//----------------------------------------------------------------------
reference LIB_FUNC CreateIterator( int tipSearch,    //тип поиска объекта
                                  reference parent ); //указатель на объект(для движения по группе, внутри макро, по слою)

// Экспортный номер - 101
//----------------------------------------------------------------------
// Двигаться по  модели.
//----------------------------------------------------------------------
reference LIB_FUNC MoveIterator( reference iterator,    //указатель на итератор
                                 unsigned char ch );    //тип движения 'F'/'N'  - первый/следующий

// Экспортный номер - 102
//----------------------------------------------------------------------
// Создать итератор для хождения по атрибутам.
// Если obj = 0, движение по объектам с заданным атрибутом внутри графического документа.
// Если obj != 0, то это может быть объект вида, вид, группа, слой, тогда
// движение будет происходить по атрибутам объекта.
// Если obj != 0, то это может быть документ, тогда
// движение будет происходить по атрибутам документа.
//----------------------------------------------------------------------
reference LIB_FUNC CreateAttrIterator( reference obj,     // указатель на объект или 0
                                       unsigned int key1, //
                                       unsigned int key2, // ключи для поиска по ключам либо 0
                                       unsigned int key3, //
                                       unsigned int key4, //
                                       double numb );     // номер типа атрибута для поиска по номеру либо 0

// Экспортный номер - 103
//----------------------------------------------------------------------
// Двигаться  по атрибутам.  Возвращается указатель на атрибут.
// Если итератор создан для  движения по элементам с определенным атрибутом,
// то pObj - указатель на объект с данным атрибутом.
// Если pObj = NULL, pObj не заполняется.
//----------------------------------------------------------------------
reference LIB_FUNC MoveAttrIterator( reference iterator,  // указатель на итератор
                                     unsigned char ch,    // тип движения 'F'/'N'
                                     reference * pObj );  // указатель на группу
// Экспортный номер - 104
//----------------------------------------------------------------------
// Удалить итератор для хождения по модели.
//----------------------------------------------------------------------
int       LIB_FUNC DeleteIterator( reference iterator ); //указатель на итератор


// Экспортный номер - 86
//--------------------------------------------------------------------------
// Создать массив неопределенной длины по типу.
// tip = [CHAR_STR_ARR ...CHAR_STR_ARR_W] см. ldefin2d.h
//--------------------------------------------------------------------------
reference  LIB_FUNC CreateArray( int tip,         //тип массива
                                 DeleteFunc  f ); //адрес функции удаления для USER_ARR


// Экспортный номер - 87
//--------------------------------------------------------------------------
// Удалить массив неопределенной длины по указателю.
//--------------------------------------------------------------------------
int        LIB_FUNC DeleteArray( reference p ); // указатель на массив

// Экспортный номер - 88
//--------------------------------------------------------------------------
// Очистить массив.
//--------------------------------------------------------------------------
int        LIB_FUNC ClearArray( reference p );  // указатель на массив

// Экспортный номер - 89
//--------------------------------------------------------------------------
// По указателю на массив неопределенной длины выдать количество элементов
// в массиве.
//--------------------------------------------------------------------------
int        LIB_FUNC GetArrayCount( reference p ); // указатель на массив

// Экспортный номер - 90
//--------------------------------------------------------------------------
// Добавить элемент в массив.
//--------------------------------------------------------------------------
int        LIB_FUNC AddArrayItem( reference p,   // указатель на массив
																	int numb,      // индекс в массиве перед которым нужно вставить элемент
																								 // если  numb =-1 ставить в конец массива
																	void * value,  // указатель на структуру элемента
																	int size );    // размер структуры элемента


// Экспортный номер - 91
//--------------------------------------------------------------------------
// Исключить элемент из массива.
//--------------------------------------------------------------------------
int        LIB_FUNC ExcludeArrayItem( reference p,  // указатель на массив
																			int numb);    // индекс в массиве ( нумерация начинается с 0 )


// Экспортный номер - 92
//--------------------------------------------------------------------------
// Получить параметры  элемента в массиве.
//--------------------------------------------------------------------------
int        LIB_FUNC GetArrayItem( reference p, // указатель на массив
																	int numb,    // индекс в массиве ( нумерация начинается с 0 )
																	void * value,// указатель на структуру элемента
																	int size );  // размер структуры элемента
// Экспортный номер - 93
//--------------------------------------------------------------------------
// Получить указатель на  элемент в пользовательском массиве.
//--------------------------------------------------------------------------
int        LIB_FUNC GetUserArrayItem( reference p,        // указатель на массив
                                      int numb,        // индекс в массиве
																			void ** value  );// указатель на указатель элемента массива

// Экспортный номер - 94
//--------------------------------------------------------------------------
// Заменить параметры  элемента в массиве.
//--------------------------------------------------------------------------
int        LIB_FUNC SetArrayItem( reference p,  // указатель на массив
																	int numb,     // индекс в массиве ( нумерация начинается с 0 )
																	void * value, // указатель на структуру элемента
																	int size );   // размер структуры элемента
// Экспортный номер - 95
//--------------------------------------------------------------------------
// Возвращается тип массива.
//--------------------------------------------------------------------------
int        LIB_FUNC GetArrayType ( reference p ); // указатель на массив

// Экспортный номер - 313
//--------------------------------------------------------------------------
// Разбить объект на составляющие части - отрезки, дуги, тексты.
// Возвращается указатель на  временную группу  компонент   сложного объекта.
// Спецификация разбивается по листам ( p- указатель на документ СП,
// type - номер листа спецификации, начиная с 1 )
// Текущим документом должен быть графический документ.
//--------------------------------------------------------------------------
reference  LIB_FUNC DecomposeObj( reference p,        //указатель на объект
                                unsigned char level,  //уровень разбиения 0 - отрезки,дуги,тексты,точки;
                                                      //                  1 - отрезки,тексты,точки; 2-отрезки, дуги, тексты
                                                      //                  4 - отрезки,дуги,точки,тексты(не разбиваем);
                                                      //                  5 - отрезки, дуги, тексты, заливки стрелок и треугольников баз
                                                      //                  6 - видимые и невидимые участки
                                double arrow,         //стрелка прогиба
                                unsigned char type);  // 0 - разбиение объекта в СК вида 1- в СК листа

// Экспортный номер - 357
//--------------------------------------------------------------------------
// Загрузить массив номеров спецсимволов  не подлежащих Decompose
// если arr == 0  или  count == 0  массив символов очищается
//--------------------------------------------------------------------------
int LIB_FUNC ksLoadNonDecomposSpecSymbols( int * arr, unsigned int count );

// Экспортный номер - 146
//--------------------------------------------------------------------------
// Возвращает число объектов в виде.
// Если p = 0, число объектов  в текущем виде или в фрагменте.
//--------------------------------------------------------------------------
long       LIB_FUNC GetViewObjCount( reference p ); //указатель на вид

// Экспортный номер - 149
//--------------------------------------------------------------------------
//  Определение фрагмента вставки.
//  Возвращается указатель на определение фрагмента, для использования
//  в функции InsertFragment, DeleteObj.
//  fileName - полное имя файла фрагмента.
//  Допускается fileName  следующего вида "c:\_f\gr\lib1.lfr|детали|литье|фланец"
//  ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
//  внутри библиотеки фрагментов, фланец - имя фрагмента ). В этом случае определение
//  создается на фрагмент из библиотеки фрагментов.
//  Определение для данного фрагмента одно - вставок может быть
//  сколько угодно.
//--------------------------------------------------------------------------
reference  LIB_FUNC FragmentDefinition( char * fileName,          //имя файла фрагмента
                                        char * comment,           //имя вставки
                                        unsigned char insertType);//тип вставки -действителен для внешнего фрагмента
                                                                 // 0- взять в документ, 1-внешней ссылкой

// Экспортный номер - 865
//--------------------------------------------------------------------------
//  Определение фрагмента вставки.
//  Возвращается указатель на определение фрагмента, для использования
//  в функции InsertFragment, DeleteObj.
//  fileName - полное имя файла фрагмента.
//  Допускается fileName  следующего вида "c:\_f\gr\lib1.lfr|детали|литье|фланец"
//  ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
//  внутри библиотеки фрагментов, фланец - имя фрагмента ). В этом случае определение
//  создается на фрагмент из библиотеки фрагментов.
//  Определение для данного фрагмента одно - вставок может быть
//  сколько угодно. (Unicode)
//--------------------------------------------------------------------------
reference  LIB_FUNC FragmentDefinitionW( LPWSTR fileName,          //имя файла фрагмента
                                         LPWSTR comment,           //имя вставки
                                         unsigned char insertType);//тип вставки -действителен для внешнего фрагмента
                                                                 // 0- взять в документ, 1-внешней ссылкой

#ifdef _UNICODE
#define FragmentDefinitionT  FragmentDefinitionW
#else
#define FragmentDefinitionT  FragmentDefinition
#endif // !UNICODE


// Экспортный номер - 150
//--------------------------------------------------------------------------
//  Вставка фрагмента.
//  Функция предназначена для вставки определенного фрагмента в конкретное
//  место чертежа.
//  Возвращается указатель на объект "Вставка фрагмента".
//--------------------------------------------------------------------------
reference  LIB_FUNC InsertFragment( reference p,              // Указатель определения  фрагмента
                                    unsigned char curentLayer,//тип размещения по слоям 0 - на свои слои 1- в текущий слой
                                    PlacementParam * par );   //параметры привязки

// Экспортный номер - 287
//--------------------------------------------------------------------------
//  Вставка фрагмента расширенная возможностью масштабирования выносных линий у размеров
//  Функция предназначена для вставки определенного фрагмента в конкретное
//  место чертежа.
//  Возвращается указатель на объект "Вставка фрагмента".
//--------------------------------------------------------------------------
reference  LIB_FUNC ksInsertFragmentEx( reference p,              // Указатель определения  фрагмента
                                        unsigned char curentLayer,//тип размещения по слоям 0 - на свои слои 1- в текущий слой
                                        PlacementParam * par,     //параметры привязки
                                        unsigned char    scaleProjLinesSize ); // масштабировать ли длину выносных линий у размеров

// Экспортный номер - 151
//--------------------------------------------------------------------------
//   Вставка фрагмента россыпью сразу в модель.
//   Функция возвращает 1 в случае успеха, 0 - в случае неудачи.
//  fileName - полное имя файла фрагмента.
//  Допускается fileName  следующего вида "c:\_f\gr\lib1.lfr|детали|литье|фланец"
//  ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
//  внутри библиотеки фрагментов, фланец - имя фрагмента ). В этом случае фрагмент
//  берется из библиотеки фрагментов
//--------------------------------------------------------------------------
int         LIB_FUNC ReadFragment( char *fileName,            // имя фрагмента
                                   unsigned char curentLayer, //тип размещения по слоям 0 - на свои слои 1- в текущий слой
                                   PlacementParam * par );    //параметры привязки


// Экспортный номер - 866
//--------------------------------------------------------------------------
//   Вставка фрагмента россыпью сразу в модель.
//   Функция возвращает 1 в случае успеха, 0 - в случае неудачи.
//  fileName - полное имя файла фрагмента.
//  Допускается fileName  следующего вида "c:\_f\gr\lib1.lfr|детали|литье|фланец"
//  ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
//  внутри библиотеки фрагментов, фланец - имя фрагмента ). В этом случае фрагмент
//  берется из библиотеки фрагментов
//  (Unicode)
//--------------------------------------------------------------------------
int         LIB_FUNC ReadFragmentW( LPWSTR fileName,            // имя фрагмента
                                    unsigned char curentLayer, //тип размещения по слоям 0 - на свои слои 1- в текущий слой
                                    PlacementParam * par );    //параметры привязки

#ifdef _UNICODE
#define ReadFragmentT  ReadFragmentW
#else
#define ReadFragmentT  ReadFragment
#endif // !UNICODE


// Экспортный номер - 226
// устаревшая функция 08.04.2002
//--------------------------------------------------------------------------
//  Вставка фрагмента россыпью во временную группу.
//   Функция возвращает указатель на временную группу в случае успеха,
//   0 - в случае неудачи.
//  fileName - полное имя файла фрагмента.
//  Допускается fileName  следующего вида "c:\_f\gr\lib1.lfr|детали|литье|фланец"
//  ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
//  внутри библиотеки фрагментов, фланец - имя фрагмента ). В этом случае фрагмент
//  берется из библиотеки фрагментов
//--------------------------------------------------------------------------
reference LIB_FUNC ksReadFragmentToGroup( char    *fileName,          // имя фрагмента
                                          unsigned char  curentLayer, // тип размещения по слоям 0 - на свои слои 1- в текущий слой
                                          PlacementParam *par );      // параметры привязки


// Экспортный номер 292
//--------------------------------------------------------------------------
//  Вставка фрагмента россыпью во временную группу.
//   Функция возвращает указатель на временную группу в случае успеха,
//   0 - в случае неудачи.
//  fileName - полное имя файла фрагмента.
//  Допускается fileName  следующего вида "c:\_f\gr\lib1.lfr|детали|литье|фланец"
//  ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
//  внутри библиотеки фрагментов, фланец - имя фрагмента ). В этом случае фрагмент
//  берется из библиотеки фрагментов
//  scaleProjLinesSize - масштабировать ли длину выносных линий у размеров
//--------------------------------------------------------------------------
reference LIB_FUNC ksReadFragmentToGroupEx( char*           fileName,    // имя фрагмента
                                            unsigned char   curentLayer, // тип размещения по слоям 0 - на свои слои 1- в текущий слой
                                            PlacementParam* par,         // параметры привязки
                                            unsigned char   scaleProjLinesSize ); // масштабировать ли длину выносных линий у размеров


// Экспортный номер 868
//--------------------------------------------------------------------------
//  Вставка фрагмента россыпью во временную группу.
//   Функция возвращает указатель на временную группу в случае успеха,
//   0 - в случае неудачи.
//  fileName - полное имя файла фрагмента.
//  Допускается fileName  следующего вида "c:\_f\gr\lib1.lfr|детали|литье|фланец"
//  ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
//  внутри библиотеки фрагментов, фланец - имя фрагмента ). В этом случае фрагмент
//  берется из библиотеки фрагментов
//  scaleProjLinesSize - масштабировать ли длину выносных линий у размеров
//  (Unicode)
//--------------------------------------------------------------------------
reference LIB_FUNC ksReadFragmentToGroupExW( LPWSTR          fileName,    // имя фрагмента
                                             unsigned char   curentLayer, // тип размещения по слоям 0 - на свои слои 1- в текущий слой
                                             PlacementParam* par,         // параметры привязки
                                             unsigned char   scaleProjLinesSize ); // масштабировать ли длину выносных линий у размеров

#ifdef _UNICODE
#define ksReadFragmentToGroupExT  ksReadFragmentToGroupExW
#else
#define ksReadFragmentToGroupExT  ksReadFragmentToGroupEx
#endif // !UNICODE


// Экспортный номер - 170
//----------------------------------------------------------------------------------------------
// Записать группу во фрагмент
// Если  gr = 0 - группа селектирования
//----------------------------------------------------------------------------------------------
int         LIB_FUNC WriteFragment( reference gr,            //указатель на группу
                                       char * filename,         //имя файла фрагмента
                                       char *comment,           //комментарий для фрагмента
                                       double xb, double yb  ); //точка привязки

// Экспортный номер - 869
//----------------------------------------------------------------------------------------------
// Записать группу во фрагмент
// Если  gr = 0 - группа селектирования (Unicode)
//----------------------------------------------------------------------------------------------
int         LIB_FUNC WriteFragmentW( reference gr,            //указатель на группу
                                       LPWSTR  filename,         //имя файла фрагмента
                                       LPWSTR  comment,           //комментарий для фрагмента
                                       double  xb, double yb  ); //точка привязки


#ifdef _UNICODE
#define WriteFragmentT  WriteFragmentW
#else
#define WriteFragmentT  WriteFragment
#endif // !UNICODE


// Экспортный номер - 152
//--------------------------------------------------------------------------
// Составной объект  определения локального фрагмента. В этом случае файла
// фрагмента нет. Тело фрагмента хранится в документе
//--------------------------------------------------------------------------
int         LIB_FUNC LocalFragmentDefinition( char * comment ); //имя вставки


// Экспортный номер - 870
//--------------------------------------------------------------------------
// Составной объект  определения локального фрагмента. В этом случае файла
// фрагмента нет. Тело фрагмента хранится в документе (Unicode)
//--------------------------------------------------------------------------
int         LIB_FUNC LocalFragmentDefinitionW( LPWSTR comment ); //имя вставки

#ifdef _UNICODE
#define LocalFragmentDefinitionT  LocalFragmentDefinitionW
#else
#define LocalFragmentDefinitionT  LocalFragmentDefinition
#endif // !UNICODE


// Экспортный номер - 153
//--------------------------------------------------------------------------
// Закончить определение локального фрагмента Все объекты вида, вводимые
// между операторами  LocalFragmentDefinition и CloseLocalFragmentDefinition,
// принадлежат локальному фрагменту.
// Возвращается указатель на определение фрагмента, для использования
// в функции InsertFragment, DeleteObj.
//--------------------------------------------------------------------------
reference  LIB_FUNC  CloseLocalFragmentDefinition( );

// Экспортный номер - 196
//----------------------------------------------------------------------------------------------
//  выбор имени фрагмента или папки в библиотеке фрагментов
//  frwName   - возвращает к примеру "c:\_f\gr\lib1.lfr|детали|литье|фланец"
//  ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
//  внутри библиотеки, фланец - имя фрагмента или имя папки ).
//  Библиотека фрагментов открывается в режиме диалога. Редактирование запрещено.
//  Enter - выбор имени фрагмента. Esc - отказ.
//  Возвращает 3 - фрагмент, 2 - папка, 1- корень библиотеки фрагментов, 0 - неудача.
//----------------------------------------------------------------------------------------------
int LIB_FUNC ksChoiceFragmentFromLib( char * frwLibFile,    // полное имя библиотеки фрагментов
                                      char * frwName,       // имя фрагмента
                                      unsigned int size );  // размер буффера frwName

// Экспортный номер - 871
//----------------------------------------------------------------------------------------------
//  выбор имени фрагмента или папки в библиотеке фрагментов
//  frwName   - возвращает к примеру "c:\_f\gr\lib1.lfr|детали|литье|фланец"
//  ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
//  внутри библиотеки, фланец - имя фрагмента или имя папки ).
//  Библиотека фрагментов открывается в режиме диалога. Редактирование запрещено.
//  Enter - выбор имени фрагмента. Esc - отказ.
//  Возвращает 3 - фрагмент, 2 - папка, 1- корень библиотеки фрагментов, 0 - неудача.
//  (Unicode)
//----------------------------------------------------------------------------------------------
int LIB_FUNC ksChoiceFragmentFromLibW( LPWSTR frwLibFile,    // полное имя библиотеки фрагментов
                                       LPWSTR frwName,       // имя фрагмента
                                       unsigned int size );  // размер буффера frwName

#ifdef _UNICODE
#define ksChoiceFragmentFromLibT  ksChoiceFragmentFromLibW
#else
#define ksChoiceFragmentFromLibT  ksChoiceFragmentFromLib
#endif // !UNICODE


// Экспортный номер - 198
//----------------------------------------------------------------------------------------------
// Открыть библиотекарь фрагментов
// libName   -  пример задания  "c:\_f\gr\lib1.lfr|детали|литье|фланец"
// ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
// внутри библиотеки, фланец - имя фрагмента ).
// type = -1 - закрыть без сохранения 0 - закрыть с сохранением,
//         1 - открыть,               2 - редактировать фрагмент,
//         3 - удалить фрагмент из библиотекаря
//         4 - минимизировать окно библиотекаря - в КОМПАС6 - нет реализации!!!!!!!!!!
//         5 - создание библиотекаря фрагментов
//         7 - создать фрагмент с присланным именем "c:\_f\gr\lib1.lfr|детали|литье|фланец" в библиотекаре фрагментов
//----------------------------------------------------------------------------------------------
int LIB_FUNC ksFragmentLibrary(  char * libName,        //имя файла библиотеки фрагментов
                                 int type );  //флаг работы с библиотекой


// Экспортный номер - 872
//----------------------------------------------------------------------------------------------
// Открыть библиотекарь фрагментов
// libName   -  пример задания  "c:\_f\gr\lib1.lfr|детали|литье|фланец"
// ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
// внутри библиотеки, фланец - имя фрагмента ).
// type = -1 - закрыть без сохранения 0 - закрыть с сохранением,
//         1 - открыть,               2 - редактировать фрагмент,
//         3 - удалить фрагмент из библиотекаря
//         4 - минимизировать окно библиотекаря - в КОМПАС6 - нет реализации!!!!!!!!!!
//         5 - создание библиотекаря фрагментов
//         7 - создать фрагмент с присланным именем "c:\_f\gr\lib1.lfr|детали|литье|фланец" в библиотекаре фрагментов
// (Unicode)
//----------------------------------------------------------------------------------------------
int LIB_FUNC ksFragmentLibraryW(  LPWSTR libName,        //имя файла библиотеки фрагментов
                                  int type );  //флаг работы с библиотекой

#ifdef _UNICODE
#define ksFragmentLibraryT  ksFragmentLibraryW
#else
#define ksFragmentLibraryT  ksFragmentLibrary
#endif // !UNICODE


// Экспортный номер - 199
//----------------------------------------------------------------------------------------------
// добавить фрагмент с именем файла  frwName в библиотеку фрагментов с именем libName
// libName   -  пример задания  "c:\_f\gr\lib1.lfr|детали|литье|фланец"
// ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
// внутри библиотеки, фланец - имя фрагмента ).
//----------------------------------------------------------------------------------------------
int LIB_FUNC ksAddFragmentToLibrary ( char * libName,   // имя файла библиотеки фрагментов
                                      char * frwName ); // имя файла фрагмента

// Экспортный номер - 873
//----------------------------------------------------------------------------------------------
// добавить фрагмент с именем файла  frwName в библиотеку фрагментов с именем libName
// libName   -  пример задания  "c:\_f\gr\lib1.lfr|детали|литье|фланец"
// ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
// внутри библиотеки, фланец - имя фрагмента ).
// (Unicode)
//----------------------------------------------------------------------------------------------
int LIB_FUNC ksAddFragmentToLibraryW ( LPWSTR libName,   // имя файла библиотеки фрагментов
                                       LPWSTR frwName ); // имя файла фрагмента

#ifdef _UNICODE
#define ksAddFragmentToLibraryT  ksAddFragmentToLibraryW
#else
#define ksAddFragmentToLibraryT  ksAddFragmentToLibrary
#endif // !UNICODE


// Экспортный номер - 215
//----------------------------------------------------------------------------------------------
// Функция проверяет открыта ли  библиотека фрагментов с данным именем,
// возвращает 1 если открыта или 0 если не открыта
//----------------------------------------------------------------------------------------------
int LIB_FUNC ksCheckFragmentLibrary( char * libName,                   // имя файла библиотеки фрагментов
                                     unsigned char possibleMessage );  // 1 - сообщать, если он уже открыт 0 - не сообщать


// Экспортный номер - 874
//----------------------------------------------------------------------------------------------
// Функция проверяет открыта ли  библиотека фрагментов с данным именем,
// возвращает 1 если открыта или 0 если не открыта (Unicode)
//----------------------------------------------------------------------------------------------
int LIB_FUNC ksCheckFragmentLibraryW( LPWSTR libName,                   // имя файла библиотеки фрагментов
                                      unsigned char possibleMessage );  // 1 - сообщать, если он уже открыт 0 - не сообщать

#ifdef _UNICODE
#define ksCheckFragmentLibraryT  ksCheckFragmentLibraryW
#else
#define ksCheckFragmentLibraryT  ksCheckFragmentLibrary
#endif // !UNICODE


// Экспортный номер - 242
//------------------------------------------------------------------------------
// Функция проверяет существует ли фрагмент с именем  frwName в библиотеке фрагментов
// frwName   -  к примеру "c:\_f\gr\lib1.lfr|детали|литье|фланец"
// ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
// внутри библиотеки, фланец - имя фрагмента или имя папки ).
//  Функция возвращает 0  - нет фрагмента или папки
//                    -1 - нет библиотеки
//                     1   фрагмент или папка есть
// ---
int LIB_FUNC ksExistFragmentInLibrary( char *frwName );


// Экспортный номер - 875
//------------------------------------------------------------------------------
// Функция проверяет существует ли фрагмент с именем  frwName в библиотеке фрагментов
// frwName   -  к примеру "c:\_f\gr\lib1.lfr|детали|литье|фланец"
// ( c:\_f\gr\lib1.lfr - имя файла библиотеки фрагментов, |детали|литье|- разделы, подразделы
// внутри библиотеки, фланец - имя фрагмента или имя папки ).
//  Функция возвращает 0  - нет фрагмента или папки
//                    -1 - нет библиотеки
//                     1   фрагмент или папка есть
// (Unicode)
// ---
int LIB_FUNC ksExistFragmentInLibraryW( LPWSTR frwName );

#ifdef _UNICODE
#define ksExistFragmentInLibraryT  ksExistFragmentInLibraryW
#else
#define ksExistFragmentInLibraryT  ksExistFragmentInLibrary
#endif // !UNICODE


// Экспортный номер - 297
//---------------------------------------------------------------------------
// Функция позволяет получить структуру дерева библиотеки документов и библиотеки
// атрибутов
// libName - полное имя файла библиотеки моделей, фрагментов, атрибутов
//---------------------------------------------------------------------------
int LIB_FUNC ksGetLibraryTreeStruct( char * libName, TreeNodeParam * root );


// Экспортный номер - 876
//---------------------------------------------------------------------------
// Функция позволяет получить структуру дерева библиотеки документов и библиотеки
// атрибутов
// libName - полное имя файла библиотеки моделей, фрагментов, атрибутов
// (Unicode)
//---------------------------------------------------------------------------
int LIB_FUNC ksGetLibraryTreeStructW( LPWSTR libName, TreeNodeParamW * root );

#ifdef _UNICODE
#define ksGetLibraryTreeStructT  ksGetLibraryTreeStructW
#else
#define ksGetLibraryTreeStructT  ksGetLibraryTreeStruct
#endif // !UNICODE


// Экспортный номер - 155
// -------------------------------------------------------------------------
// Освободить указатель объекта. Не временный объект не уничтожается.
// В результате таблица объектов сокращается, а операции, связанные с пербором
// объектов ускоряются.
// -------------------------------------------------------------------------
int        LIB_FUNC ReleaseReference( reference p );  //указатель на объект

// ------------------------------------------------------------------------
// раздел : Описание чертежа
// ------------------------------------------------------------------------

// Экспортный номер - 96
//----------------------------------------------------------------------
// Создать документ -лист или фрагмент.
// Документ становится текущим ( видимыым или не видимым ).
// Задается полное имя файла. Возвращает указатель на документ или 0 в случае неудачи.
//----------------------------------------------------------------------
reference LIB_FUNC CreateDocument ( DocumentParam * par );// параметры документа


// Экспортный номер - 801
//----------------------------------------------------------------------
// Создать документ -лист или фрагмент.
// Документ становится текущим ( видимыым или не видимым ).
// Задается полное имя файла. Возвращает указатель на документ или 0 в случае неудачи.
//----------------------------------------------------------------------
reference LIB_FUNC CreateDocumentW ( DocumentParamW * par );// параметры документа


#ifdef _UNICODE
#define CreateDocumentT  CreateDocumentW
#else
#define CreateDocumentT  CreateDocument
#endif // !UNICODE

// Экспортный номер - 706
//----------------------------------------------------------------------
// Создать текстовый документ
// документ становится текущим ( видимыым или не видимым )
// задается полное имя файла
// возвращает указатель на документ
//----------------------------------------------------------------------
reference LIB_FUNC CreateTextDocument ( TextDocumentParam * par ); // параметры текстового документа

// Экспортный номер - 877
//----------------------------------------------------------------------
// Создать текстовый документ
// документ становится текущим ( видимыым или не видимым )
// задается полное имя файла
// возвращает указатель на документ (Unicode)
//----------------------------------------------------------------------
reference LIB_FUNC CreateTextDocumentW ( TextDocumentParamW * par ); // параметры текстового документа

#ifdef _UNICODE
#define CreateTextDocumentT  CreateTextDocumentW
#else
#define CreateTextDocumentT  CreateTextDocument
#endif // !UNICODE


// Экспортный номер - 97
//----------------------------------------------------------------------
// Открыть  документ (лист, фрагмент, спецификацию, 3d документ).
// состояние : 0 - видимый режим,  1 - слепой режим
// для спецификации 3 - видимый режим  без синхронизации со сборкой
// для спецификации 4 - слепой режим   без синхронизации со сборкой
// Документ становится текущим.  Задается полное имя файла.
// Возвращает указатель на документ или 0 в случае неудачи.
//----------------------------------------------------------------------
reference LIB_FUNC OpenDocument   ( char *nameDoc,        //- имя документа
                                    unsigned char regim );// 0 - видимый режим,
                                                          // 1 - невидимый режим

// Экспортный номер - 878
//----------------------------------------------------------------------
// Открыть  документ (лист, фрагмент, спецификацию, 3d документ).
// состояние : 0 - видимый режим,  1 - слепой режим
// для спецификации 3 - видимый режим  без синхронизации со сборкой
// для спецификации 4 - слепой режим   без синхронизации со сборкой
// Документ становится текущим.  Задается полное имя файла.
// Возвращает указатель на документ или 0 в случае неудачи. (Unicode)
//----------------------------------------------------------------------
reference LIB_FUNC OpenDocumentW   ( LPWSTR nameDoc,       //- имя документа
                                     unsigned char regim );// 0 - видимый режим,
                                                           // 1 - невидимый режим

#ifdef _UNICODE
#define OpenDocumentT  OpenDocumentW
#else
#define OpenDocumentT  OpenDocument
#endif // !UNICODE


// Экспортный номер - 98
//----------------------------------------------------------------------
// Сохранить  документ.
// Возвращает 1 в случае успеха или 0 в случае неудачи.
// Задается полное имя файла. Если fileName - NULL, используется имя файла из
// документа. Если и в документе имя  файла NULL взводится ошибка.
// Если sheet = 0 сохраняем текущий документ.
//----------------------------------------------------------------------
int       LIB_FUNC SaveDocument ( reference sheet,     // указатель документа
                                   char * fileName );  // имя файла документа для режима Safe as... или NULL


// Экспортный номер - 755
//----------------------------------------------------------------------
// [31.03.2005]
// сохранить  документ
// возвращает 1 в случае успеха или 0 в случае неудачи
// задается полное имя файла
// если fileName - NULL - используется  имя файла из документа
// если и в документе имя  файла NULL взводится ошибка
// если sheet=0 сохраняем текущий документ
// saveMode = -1 - в предыдущую версию
//             0 - в текущую версию
//             1 - в версию  5.11
//----------------------------------------------------------------------
int LIB_FUNC SaveDocumentEx ( reference sheet, char * fileName, int saveMode );


// Экспортный номер - 880
//----------------------------------------------------------------------
// [04.07.2007]
// сохранить  документ
// возвращает 1 в случае успеха или 0 в случае неудачи
// задается полное имя файла
// если fileName - NULL - используется  имя файла из документа
// если и в документе имя  файла NULL взводится ошибка
// если sheet=0 сохраняем текущий документ
// saveMode = -1 - в предыдущую версию
//             0 - в текущую версию
//             1 - в версию  5.11
// (Unicode)
//----------------------------------------------------------------------
int LIB_FUNC SaveDocumentExW ( reference sheet, LPWSTR fileName, int saveMode );

#ifdef _UNICODE
#define SaveDocumentExT  SaveDocumentExW
#else
#define SaveDocumentExT  SaveDocumentEx
#endif // !UNICODE


// Экспортный номер - 700 
//----------------------------------------------------------------------
// сохранить  документ в растровый формат
// возвращает 1 в случае успеха или 0 в случае неудачи
// задается полное имя файла
// если sheet=0 сохраняем текущий документ
//----------------------------------------------------------------------
int LIB_FUNC ksSaveAsToRasterFormat ( reference sheet,           // указатель документа
                                      char * fileName,            // имя файла документа
                                      RasterFormatParam * par );  //структура параметров для конвертации в растровый формат

// Экспортный номер - 881 
//----------------------------------------------------------------------
// сохранить  документ в растровый формат
// возвращает 1 в случае успеха или 0 в случае неудачи
// задается полное имя файла
// если sheet=0 сохраняем текущий документ (Unicode)
//----------------------------------------------------------------------
int LIB_FUNC ksSaveAsToRasterFormatW ( reference sheet,           // указатель документа
                                       LPWSTR fileName,            // имя файла документа
                                       RasterFormatParamW * par );  //структура параметров для конвертации в растровый формат
  
#ifdef _UNICODE
#define ksSaveAsToRasterFormatT  ksSaveAsToRasterFormatW
#else
#define ksSaveAsToRasterFormatT  ksSaveAsToRasterFormat
#endif // !UNICODE

  
// Экспортный номер - 706 
//----------------------------------------------------------------------
// сохранить  документ в растровый формат без сжатия
// возвращает 1 в случае успеха или 0 в случае неудачи
// задается полное имя файла
// если sheet=0 сохраняем текущий документ
//----------------------------------------------------------------------
int LIB_FUNC ksSaveAsToUncompressedRasterFormat
                                    ( reference sheet,           // указатель документа
                                      char * fileName,            // имя файла документа
                                      RasterFormatParam * par );  //структура параметров для конвертации в растровый формат

// Экспортный номер - 882 
//----------------------------------------------------------------------
// сохранить  документ в растровый формат без сжатия
// возвращает 1 в случае успеха или 0 в случае неудачи
// задается полное имя файла
// если sheet=0 сохраняем текущий документ (Unicode)
//----------------------------------------------------------------------
int LIB_FUNC ksSaveAsToUncompressedRasterFormatW
                                    ( reference sheet,           // указатель документа
                                      LPWSTR fileName,            // имя файла документа
                                      RasterFormatParamW * par );  //структура параметров для конвертации в растровый формат

#ifdef _UNICODE
#define ksSaveAsToUncompressedRasterFormatT  ksSaveAsToUncompressedRasterFormatW
#else
#define ksSaveAsToUncompressedRasterFormatT  ksSaveAsToUncompressedRasterFormat
#endif // !UNICODE
  
// Экспортный номер - 99
//----------------------------------------------------------------------
// Закрыть  документ. Возвращает 1 в случае успеха или 0 в случае неудачи.
// Если документ  не  сохранили, взводится соответствующая ошибка.
// Если sheet = 0, закрываем  текущий документ.
//----------------------------------------------------------------------
int       LIB_FUNC CloseDocument ( reference sheet );  // указатель документа

// Экспортный номер - 234
//-------------------------------------------------------------------------------
// Получить текущий документ
// Функция возвращает указатель на документ в случае успеха или 0 в случае неудачи
//-------------------------------------------------------------------------------
reference LIB_FUNC ksGetCurrentDocument( unsigned char type ); // 0 - любой документ
                                                               // 1 - только графический документ
                                                               // 2 - только спецификацию
                                                               // 3 - 3d документ
                                                               // 4 - текстовый документ

// Экспортный номер - 718
//-----------------------------------------------------------------------------
// Перестроить 2D чертеж
// Позволяет перестроить все ассоциативные виды чертежа. Если в чертеже нет ни одного ассоциативного вида, 
// перестраиваться ничего не будет.
// После этого ассоциативные виды перерисовываются в соответствии с моделями, изображение которых в них содержится.
// Если sheet == 0 для активного документа.
// Функция взвращает 1 в случае успеха, 0 - в случае неудачи
// ---
int LIB_FUNC ksRebuildDocument( reference sheet ); // указатель на 2D документ -чертеж

// Экспортный номер - 130
//-------------------------------------------------------------------------------
//  Открывает технические требования. Объект действителен для листа.
//  Составной объект. Объекты TextLine, вводимые между орераторами
//  OpenTechnicalDemand и  CloseTechnicalDemand, принадлежат техническим требованиям.
//  Технические требования, могут состоять из нескольких строк, строки могут
//  состоять из нескольких компонент. Компоненты могут изменять параметры
//  текущего фонта.
//  CloseTechnicalDemand возвращает указатель на технические требования.
//-------------------------------------------------------------------------------
int       LIB_FUNC OpenTechnicalDemand( reference  pGab,       //динамический массив листов технических требований или 0
                                        unsigned short style); //стиль текста для технических требований если 0 - умолчательное значение
// Экспортный номер - 131
//-------------------------------------------------------------------------------
// Закрыть составной объект "технические требования".
// возвращает указатель на технические требования.
//-------------------------------------------------------------------------------
reference       LIB_FUNC CloseTechnicalDemand( );

// Экспортный номер - 136
//--------------------------------------------------------------------------------
//  Открыть составной объект "штамп". Действительно для первого листа.
//  Операторы    ColumnNumber  и TextLine, вводимые между операторами
//  OpenStamp  и CloseStamp, принадлежат штампу.
//  ColumnNumber  определяет номер ячейки, куда помещать текcт.
//  Номера определены в соответствии с ГОСТ на данный штамп.
//  CloseStamp возвращает указатель на штамп.
//--------------------------------------------------------------------------------
int       LIB_FUNC OpenStamp();


// Экспортный номер - 760
//--------------------------------------------------------------------------------
//  Открыть составной объект "штамп". Действительно для листа.
//  Операторы    ColumnNumber  и TextLine, вводимые между операторами
//  OpenStamp  и CloseStamp, принадлежат штампу.
//  ColumnNumber  определяет номер ячейки, куда помещать текcт.
//  Номера определены в соответствии с ГОСТ на данный штамп.
//  CloseStamp возвращает указатель на штамп.
//  sheetNumb - номер листа, начиная с 1 
// [20.06.2005]
//---------------------------------------------------------------------------
int  LIB_FUNC OpenStampEx( int sheetNumb );


// Экспортный номер - 137
//--------------------------------------------------------------------------------
//  Закрыть составной объект "штамп". Действительно для листа.
//--------------------------------------------------------------------------------
reference       LIB_FUNC CloseStamp( );

// Экспортный номер - 138
//---------------------------------------------------------------------------
// Определть номер ячейки.
// Функция используется в режиме редактирования штампа, таблицы, допуска формы,
// в режиме создания допуска формы
//---------------------------------------------------------------------------
int       LIB_FUNC ColumnNumber( unsigned int numb );

// Экспортный номер - 139
//---------------------------------------------------------------------------
// Очистить составной объект - штамп. Действительно для первого листа.
// Если numb = 0, очищаем весь штамп. В противном случае - определенную ячейку.
//---------------------------------------------------------------------------
int       LIB_FUNC ClearStamp( unsigned int numb );

// Экспортный номер - 761
//---------------------------------------------------------------------------
// Очистить составной объект - штамп. Действительно для листа.
// Если numb = 0, очищаем весь штамп. В противном случае - определенную ячейку.
// [20.06.2005]
//---------------------------------------------------------------------------
int       LIB_FUNC ClearStampEx( int sheetNumb, unsigned int numb );



// Экспортный номер - 179
//---------------------------------------------------------------------------
// Функция выдает текст графы, и смещается на следующую графу
// Если не определен номер графы с помощью функции ColumnNumber,  начинает с первой
// графы
// Возвращает указатель на динамический массив  строк текста - TEXT_LINE_ARR
// или 0, когда все графы пройдены или в случае ошибки
// после использования массив желательно удалить                 OpenStamp( );
// если  numb != NULL -возвращает номер графы                    GetStampColumnText(...);
// Функция используется в режиме редактирования штампа           CloseStamp( );
//---------------------------------------------------------------------------
reference  LIB_FUNC GetStampColumnText( unsigned int *numb );

// Экспортный номер - 235
//---------------------------------------------------------------------------
// Функция заменяет текст графы                                  OpenStamp( );
// Функция используется в режиме редактирования штампа           SetStampColumnText(...);
// Возвращает 1 в случае успеха и 0 в случае неудачи             CloseStamp( );
//---------------------------------------------------------------------------
int  LIB_FUNC SetStampColumnText( unsigned int numb,     //номер ячейки
                                  reference textArr );   //динамический массив строк текста - TEXT_LINE_ARR

// Экспортный номер - 731
//---------------------------------------------------------------------------
// Установить параметры материала в чертеже
// material - наименование материала, динамический массив строк текста (TEXT_LINE_ARR)
// density  - плотность
// Возвращает 1 в случае успеха и 0 в случае неудачи             
//---------------------------------------------------------------------------
int LIB_FUNC ksSetMaterialParam( reference material, double density );

// Экспортный номер - 324
//-------------------------------------------------------------------------------
// Если текущий документ  лист, функция позволит получить указатель:
// t=0 -на штамп,      для первого листа
// t=1 -технические требования,
// t=2 -неуказанную шероховатость
// t=3 -текущий вид
// t=4 -спецификация на листе; для текущей СП
// t=5 -текущий слой
// t=6 -таблица изменений  для первого листа
//-------------------------------------------------------------------------------
reference  LIB_FUNC GetReferenceDocumentPart( unsigned char t );

// Экспортный номер - 762
//-------------------------------------------------------------------------------
// если текущий документ лист
// функция позволит получить указатель:
// t=0 -на штамп,                 sheetNumb - номер листа, начиная с 1 
// t=1 -технические требования,   sheetNumb - не используется
// t=2 -неуказанную шероховатость sheetNumb - не используется
// t=3 -текущий вид               sheetNumb - не используется
// t=4 -спецификация на листе;    sheetNumb - номер СП, начиная с 1; 0 - текущая СП  
// t=5 -текущий слой              sheetNumb - не используется
// t=6 -таблица изменений         sheetNumb - номер листа, начиная с 1 
// [20.06.2005]
//-------------------------------------------------------------------------------
reference  LIB_FUNC GetReferenceDocumentPartEx( unsigned char t, int sheetNumb );


// Экспортный номер - 76
//--------------------------------------------------------------------------
// Создать вид. Вид становится текущим. Возвращается указатель на вид.
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number = n, создается вид с номером n. Если вид n существует,
// ничего не создается ( reference = 0) - ошибка.
//--------------------------------------------------------------------------
reference LIB_FUNC CreateSheetView( ViewParam * par, //указатель на структуру параметров вида
																		int * number );  //номер вида

// Экспортный номер - 792
//--------------------------------------------------------------------------
// Создать вид. Вид становится текущим. Возвращается указатель на вид.
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number = n, создается вид с номером n. Если вид n существует,
// ничего не создается ( reference = 0) - ошибка.
//--------------------------------------------------------------------------
reference LIB_FUNC CreateSheetViewW( ViewParamW * par, //указатель на структуру параметров вида
																		 int * number );   //номер вида

#ifdef _UNICODE
#define CreateSheetViewT  CreateSheetViewW
#else
#define CreateSheetViewT  CreateSheetView
#endif // !_UNICODE


// Экспортный номер - 710
//--------------------------------------------------------------------------
// Создать произвольный ассоциативный  вид
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number=n; создается вид с номером n , если вид n существует
// ничего не создается   reference=0 - ошибка
// Вид становится текущим, возвращает указатель на вид
//--------------------------------------------------------------------------
reference LIB_FUNC ksCreateSheetArbitraryView( AssociationViewParam *par, //параметры ассоциативного вида
                                               int *number );             // номер вида

// Экспортный номер - 793
//--------------------------------------------------------------------------
// Создать произвольный ассоциативный  вид
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number=n; создается вид с номером n , если вид n существует
// ничего не создается   reference=0 - ошибка
// Вид становится текущим, возвращает указатель на вид
//--------------------------------------------------------------------------
reference LIB_FUNC ksCreateSheetArbitraryViewW( AssociationViewParamW *par, //параметры ассоциативного вида
                                                int *number );              // номер вида

#ifdef _UNICODE
#define ksCreateSheetArbitraryViewT  ksCreateSheetArbitraryViewW
#else
#define ksCreateSheetArbitraryViewT  ksCreateSheetArbitraryView
#endif // !_UNICODE

// Экспортный номер - 711
//--------------------------------------------------------------------------
// Создать стандартные ассоциативные виды
// возвращает 1 в случае успеха, 0 в случае неудачи
//--------------------------------------------------------------------------
int LIB_FUNC ksCreateSheetStandartViews( AssociationViewParam * par, //параметры ассоциативного вида
                                         unsigned int   bitVector,   // набор типов видов из VIEW_FRONT...VIEW_ISO, которые нужно создать
                                         double         dx,          // расстояние между видами по горизонтали
                                         double         dy );        // расстояние между видами по вертикали

// Экспортный номер - 794
//--------------------------------------------------------------------------
// Создать стандартные ассоциативные виды
// возвращает 1 в случае успеха, 0 в случае неудачи
//--------------------------------------------------------------------------
int LIB_FUNC ksCreateSheetStandartViewsW( AssociationViewParamW * par,//параметры ассоциативного вида
                                          unsigned int   bitVector,   // набор типов видов из VIEW_FRONT...VIEW_ISO, которые нужно создать
                                          double         dx,          // расстояние между видами по горизонтали
                                          double         dy );        // расстояние между видами по вертикали

#ifdef _UNICODE
#define ksCreateSheetStandartViewsT  ksCreateSheetStandartViewsW
#else
#define ksCreateSheetStandartViewsT  ksCreateSheetStandartViews
#endif // !_UNICODE


// Экспортный номер - 712
//--------------------------------------------------------------------------
// Создать проекционный ассоциативный вид
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number=n; создается вид с номером n , если вид n существует
// ничего не создается   reference=0 - ошибка
// Вид становится текущим, возвращает указатель на вид
//--------------------------------------------------------------------------
reference LIB_FUNC ksCreateSheetProjectionView( AssociationViewParam * par, //параметры ассоциативного вида
                                                int *number,                // номер вида         
                                                reference view );           //указатель на базовый вид

// Экспортный номер - 795
//--------------------------------------------------------------------------
// Создать проекционный ассоциативный вид
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number=n; создается вид с номером n , если вид n существует
// ничего не создается   reference=0 - ошибка
// Вид становится текущим, возвращает указатель на вид
//--------------------------------------------------------------------------
reference LIB_FUNC ksCreateSheetProjectionViewW( AssociationViewParamW * par,//параметры ассоциативного вида
                                                 int *number,                // номер вида         
                                                 reference view );           //указатель на базовый вид

#ifdef _UNICODE
#define ksCreateSheetProjectionViewT  ksCreateSheetProjectionViewW
#else
#define ksCreateSheetProjectionViewT  ksCreateSheetProjectionView
#endif // !_UNICODE


// Экспортный номер - 713
//--------------------------------------------------------------------------
// Создать ассоциативный вид по стрелке
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number=n; создается вид с номером n , если вид n существует
// ничего не создается   reference=0 - ошибка
// Вид становится текущим, возвращает указатель на вид
//--------------------------------------------------------------------------
reference LIB_FUNC ksCreateSheetArrowView( AssociationViewParam * par, // параметры ассоциативного вида
                                           int * number,               // номер вида         
                                           reference obj );            // указатель на объект "стрелка вида"

// Экспортный номер - 796
//--------------------------------------------------------------------------
// Создать ассоциативный вид по стрелке
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number=n; создается вид с номером n , если вид n существует
// ничего не создается   reference=0 - ошибка
// Вид становится текущим, возвращает указатель на вид
//--------------------------------------------------------------------------
reference LIB_FUNC ksCreateSheetArrowViewW( AssociationViewParamW * par, // параметры ассоциативного вида
                                            int * number,                // номер вида         
                                            reference obj );             // указатель на объект "стрелка вида"

#ifdef _UNICODE
#define ksCreateSheetArrowViewT  ksCreateSheetArrowViewW
#else
#define ksCreateSheetArrowViewT  ksCreateSheetArrowView
#endif // !_UNICODE

// Экспортный номер - 714
//--------------------------------------------------------------------------
// Создать ассоциативный вид разреза\сечения
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number=n; создается вид с номером n , если вид n существует
// ничего не создается   reference=0 - ошибка
// Вид становится текущим, возвращает указатель на вид
//--------------------------------------------------------------------------
reference LIB_FUNC ksCreateSheetSectionView( AssociationViewParam * par,  // параметры ассоциативного вида
                                             int * number,                // номер вида         
                                             reference obj );             // указатель на объект линия разреза

// Экспортный номер - 797
//--------------------------------------------------------------------------
// Создать ассоциативный вид разреза\сечения
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number=n; создается вид с номером n , если вид n существует
// ничего не создается   reference=0 - ошибка
// Вид становится текущим, возвращает указатель на вид
//--------------------------------------------------------------------------
reference LIB_FUNC ksCreateSheetSectionViewW( AssociationViewParamW * par, // параметры ассоциативного вида
                                              int * number,                // номер вида         
                                              reference obj );             // указатель на объект линия разреза

#ifdef _UNICODE
#define ksCreateSheetSectionViewT  ksCreateSheetSectionViewW
#else
#define ksCreateSheetSectionViewT  ksCreateSheetSectionView
#endif // !_UNICODE

// Экспортный номер - 715
//--------------------------------------------------------------------------
//  создать ассоциативный выносной вид
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number=n; создается вид с номером n , если вид n существует
// ничего не создается   reference=0 - ошибка
// Вид становится текущим, возвращает указатель на вид
//--------------------------------------------------------------------------
reference LIB_FUNC ksCreateSheetRemoteView( AssociationViewParam * par, // параметры ассоциативного вида
                                            int * number,               // номер вида         
                                            reference obj );            // указатель на объект "Обозначение выносного элемента"


// Экспортный номер - 798
//--------------------------------------------------------------------------
//  создать ассоциативный выносной вид
// Если указать *number = 0, создается вид с номером  по возрастанию.
// Если *number=n; создается вид с номером n , если вид n существует
// ничего не создается   reference=0 - ошибка
// Вид становится текущим, возвращает указатель на вид
//--------------------------------------------------------------------------
reference LIB_FUNC ksCreateSheetRemoteViewW( AssociationViewParamW * par, // параметры ассоциативного вида
                                             int * number,                // номер вида         
                                             reference obj );             // указатель на объект "Обозначение выносного элемента"
 
#ifdef _UNICODE
#define ksCreateSheetRemoteViewT  ksCreateSheetRemoteViewW
#else
#define ksCreateSheetRemoteViewT  ksCreateSheetRemoteView
#endif // !_UNICODE

// Экспортный номер - 758
//-------------------------------------------------------------------------------
// Матрица ассоциативного вида. Возвращаемое значение : SAFEARRAY double (VT_ARRAY | VT_R8)
// В массиве будут лежать 16 элементов, которые представляют матрицу размера 4х4.
// ---
VARIANT LIB_FUNC ksAssociationViewMatrix3D( reference view );


// Экспортный номер - 759
//-------------------------------------------------------------------------------
// Преобразовать координаты 3D точки в координаты ассоциативного вида
// Возвращает 1 - в случае успеха, 0 - в случае неудачи
// ---
int LIB_FUNC ksPoint3DToAssociationView( reference view,                      // указатель на ассоциативный вид
                                         double x3D, double y3D, double z3D,  // координаты 3D точки 
                                         double * x2D, double * y2D );        // результат - координаты в ассоциативном виде

// Экспортный номер - 77
//--------------------------------------------------------------------------
// Возвращается указатель на вид   по номеру вида.
// Если  вида c задданым номером нет,  возвращает 0.
//--------------------------------------------------------------------------
reference LIB_FUNC GetViewReference( int number );

// Экспортный номер - 78
//--------------------------------------------------------------------------
// Возвращается номер вида  по указателю на вид;
// В случае  ошибки  возвращает -1. Системный вид  имеет номер 0.
// Если p-объект вида, возвращается номер вида этого объекта.
// Если p = 0 - то возвращает номер текущего вида
//--------------------------------------------------------------------------
int       LIB_FUNC GetViewNumber( reference p ); // p  - указатель на вид или объект

// Экспортный номер - 79
//--------------------------------------------------------------------------
// Открыть вид по номеру, в результате становится текущим. Вид должен быть создан.
// Возвращается  1 в случае успеха, 0 в случае  ошибки.
//--------------------------------------------------------------------------
reference LIB_FUNC OpenView( int number );   //number - номер вида

// Экспортный номер - 127
//--------------------------------------------------------------------------
//  Возвращается номер следующиго вида или 0 при неудаче.
//--------------------------------------------------------------------------
int       LIB_FUNC NewViewNumber( );

// Экспортный номер - 80
//--------------------------------------------------------------------------
//  Переопределение текущего слоя. Если слоя с заданным номером нет, слой
//  создается.
//--------------------------------------------------------------------------
reference LIB_FUNC Layer(int n);             //n - номер слоя

// Экспортный номер - 81
//--------------------------------------------------------------------------
// Возвращает номер слоя  по указателю на объект.
// В случае ошибки  возвращает -1. Системный слой имеет  номер 0.
// Если p -объект слоя, возвращается номер слоя этого объекта.
// Если p = 0 - то возвращает номер текущего слоя
//--------------------------------------------------------------------------
int       LIB_FUNC GetLayerNumber( reference p );//p - указатель на слой или объект

// Экспортный номер - 82
//--------------------------------------------------------------------------
// Возвращает указатель на слой по номеру слоя для текущего вида.
// Если  слоя c задданым номером нет,  возвращает 0.
//--------------------------------------------------------------------------
reference LIB_FUNC GetLayerReference( int  number ); //number - номер слоя

// Экспортный номер - 172
//--------------------------------------------------------------------------------------------
// Изменить слой одного объекта. Новый слой должен существовать и быть доступным
// для редактирования (не фоновым и не выключенным)
// Функция возвращает 1 в случае успеха, 0 - неудача
//--------------------------------------------------------------------------------------------
int       LIB_FUNC  ChangeObjectLayer( reference obj, // указатель объекта
                                       int number );  //- номер слоя, куда переносится объект

// Экспортный номер - 221
//------------------------------------------------------------------------------
//  Запустить окно просмотра документов перед печатью  и печать
//  docsArr - массив полных имен документов, которые нужно распечатать
//  Функция возвращает 1 в случае успеха или 0 при неудаче.
// ---
int LIB_FUNC ksPrintPreviewWindow( reference docsArr,   // динамический массив указателей CHAR_STR_ARR или CHAR_STR_ARR_W
                                   int       inquiry ); // 1 - если docsArr = 0 или массив пуст запросить документы у пользователя
                                                        // 0 - без запроса



// Экспортный номер - 222
//------------------------------------------------------------------------------
// Отрисовать Компас-документ как слайд в присланном окне
// ---
int LIB_FUNC ksDrawKompasDocument( void * HWindow,       // несущее окно
                                   LPSTR  docFileName ); // полное имя файла документа


// Экспортный номер - 799
//------------------------------------------------------------------------------
// Отрисовать Компас-документ как слайд в присланном окне ( Unicode )
// ---
int LIB_FUNC ksDrawKompasDocumentW( void * HWindow,       // несущее окно
                                    LPWSTR docFileName ); // полное имя файла документа

#ifdef _UNICODE
#define ksDrawKompasDocumentT  ksDrawKompasDocumentW
#else
#define ksDrawKompasDocumentT  ksDrawKompasDocument
#endif // !_UNICODE


// Экспортный номер - 719
//------------------------------------------------------------------------------
// Отрисовать Компас-документ как слайд в присланном окне
// ---
int LIB_FUNC ksDrawKompasDocumentByReference( void *HWindow,     // несущее окно
                                              reference pDoc );  // указатель на документ

// Экспортный номер - 241
//------------------------------------------------------------------------------
// Отрисовать группу как слайд в присланном окне
// ---
int  LIB_FUNC ksDrawKompasGroup ( void     *HWindow, // несущее окно
                                  reference gr );    // группа


// Экспортный номер - 957
//------------------------------------------------------------------------------
// Отрисовать текст в формате Компаса на окне
// ---
int  LIB_FUNC ksDrawKompasText( void  *HWindow, // несущее окно
                                LPSTR text );   // Текст

// Экспортный номер - 958
//------------------------------------------------------------------------------
// Отрисовать текст в формате Компаса на окне
// ---
int  LIB_FUNC ksDrawKompasTextW( void  *HWindow, // несущее окно
                                 LPWSTR text );  // Текст


#ifdef _UNICODE
#define ksDrawKompasTextT  ksDrawKompasTextW
#else
#define ksDrawKompasTextT  ksDrawKompasText
#endif // !_UNICODE


// Экспортный номер - 227
//------------------------------------------------------------------------------
// Создать таблицу, используя информацию, хранящуюся в файле *.tbl
// ---
reference  LIB_FUNC ksReadTableFromFile( LPSTR tblFileName ); // полное имя к файлу таблицы

// Экспортный номер - 802
//------------------------------------------------------------------------------
// Создать таблицу, используя информацию, хранящуюся в файле *.tbl
// ---
reference  LIB_FUNC ksReadTableFromFileW( LPWSTR tblFileName ); // полное имя к файлу таблицы

#ifdef _UNICODE
#define ksReadTableFromFileT  ksReadTableFromFileW
#else
#define ksReadTableFromFileT  ksReadTableFromFile
#endif // !_UNICODE


// Экспортный номер - 374
//------------------------------------------------------------------------------
// Получить группу графических объектов, определяющих область выделения,
// используя визуальный процесс.
// Так как сиcтема может работать только с одним процессом, то нужно завершить
// другие процессные функции: Cursor, Placement, CommandWindow, ksEditViewObject.
// Функция возвращает  временную группу или 0 в случае неудачи
// ---
reference LIB_FUNC ksViewGetObjectArea();




// Экспортный номер - 232
//------------------------------------------------------------------------------
// Функция возвращает массив  параметрических переменных
// графического документа или вставки фрагмента.
// Возвращает указатель на динамический массив структур VariableParam или 0 в случае неудачи
// ---
reference LIB_FUNC ksGetDocVariableArray( reference p ); //указатель на документ или вставку фрагмента


// Экспортный номер - 233
//------------------------------------------------------------------------------
// Функция заменяет значения и если нужно комментарии у параметрических переменных
// графического документа или вставки фрагмента.
// Возвращает 1 в случае успеха или 0 в случае неудачи
// ---
int LIB_FUNC ksSetDocVariableArray( reference obj,             // указатель на документ или вставку фрагмента
                                    reference arr,             // указатель на динамический массив VARIABLE_ARR
                                    unsigned char setNote  );  // 0 - комментарии не менять 1 комментарии менять


// Экспортный номер - 397
//------------------------------------------------------------------------------
// Установить параметрическое ограничение.
// Функция возвращает 1 в случае успеха 0 в случае неудачи
// ---
int LIB_FUNC ksSetObjConstraint( reference obj, ConstraintParam *par );


// Экспортный номер - 399
//------------------------------------------------------------------------------
// Получить параметрические ограничения, наложенные на объект.
// Функция возвращает указатель на динамический массив ограничений ConstraintParam.
// В случае неудачи или при отсутствии ограничений возвращается 0
// ---
reference LIB_FUNC ksGetObjConstraints( reference obj );// указатель на объект


// Экспортный номер - 403
//------------------------------------------------------------------------------
// Удалить параметрическое ограничение.
// Функция возвращает 1 в случае успеха 0 в случае неудачи
// ---
int LIB_FUNC ksDestroyObjConstraint( reference obj, ConstraintParam *par );

// Экспортный номер - 255
//--------------------------------------------------------------------------
// Получить точку привязки и угол поворота - СК масрообъекта
// Если m = 0 - редактируемый макро
// angl - угол поворота от оси OX против часовой стрелки в градусах
// В случае удачи функция возвращает 1, в случае неудачи - 0
// Если у макрообъекта нет СК ( не вызывалась функция SetMacroPlacement ) - функция
// возвращает -1
//--------------------------------------------------------------------------
int LIB_FUNC GetMacroPlacement( reference macro, double *x, double *y, double *angl );

// Экспортный номер - 730
//--------------------------------------------------------------------------
// тоже что и GetMacroPlacement, с управлением в какой системе координат получить СК Макрообъекта
// sheetParam = 1 - в системе координат листа 
// sheetParam = 0 - 
//--------------------------------------------------------------------------
int LIB_FUNC ksGetMacroPlacement( reference macro, double *x, double *y, 
                                  double *angl, unsigned char sheetParam );

// Экспортный номер - 994
//--------------------------------------------------------------------------
// тоже что и ksGetMacroPlacement,в дополнение можно получить флаг зеркальной симметрии объекта
// *mirrorSymmetry = 0 - нормаотный исходный объект
// *mirrorSymmetry = 1 - макрообъект получен операцией симметрии из исходного
// mirrorSymmetry = NULL - не заполняется
//--------------------------------------------------------------------------
int LIB_FUNC ksGetMacroPlacementEx( reference macro, double *x, double *y, 
                                    double *angl, unsigned char sheetParam, 
                                    unsigned char * mirrorSymmetry );   //флаг зеркальной симметрии объекта

// Экспортный номер - 256
//--------------------------------------------------------------------------
// Установить точку привязки и угол поворота - систему координат макрообъекта
// angl - угол поворота от оси OX против часовой стрелки в градусах
// relativ = 1 - (x, y, angl) - смещения относительно  с.к. редактируемого макрообъекта
// relativ = 0 - (x, y, angl) - абсолютное значение в с.к. вида
//--------------------------------------------------------------------------
int LIB_FUNC SetMacroPlacement( reference macro, double x, double y, double angl, int relativ );

// Экспортный номер - 995
//--------------------------------------------------------------------------
// тоже что и SetMacroPlacement,в дополнение можно передать флаг зеркальной симметрии объекта
// mirrorSymmetry = 0 - нормаотный исходный объект
// mirrorSymmetry = 1 - макрообъект получен операцией симметрии из исходного
// mirrorSymmetry можно получить ф. ksGetMacroPlacementEx
//--------------------------------------------------------------------------
int LIB_FUNC ksSetMacroPlacementEx( reference macro, double x, double y, double angl, int relative, 
                                    char mirrorSymmetry ); //флаг зеркальной симметрии объекта

// Экспортный номер - 409
//------------------------------------------------------------------------------
// Получить зону текущего документа (графического) по заданной точке.
// Функция возвращает:
//  0  - ошибка (например точка вне документа, документ не лист и  );
//  -1 - в текущем документе нет разбиения на зоны;
//  1  - успешное завершение.
// ---
int LIB_FUNC ksGetZona( double x, double y,   //x,y - координаты точки в текущем документе;
                        LPSTR  zona,          //буфер для возврата зоны;
                        int    size );        //размер присланного буфера

// Экспортный номер - 
//------------------------------------------------------------------------------
// Получить зону текущего документа (графического) по заданной точке.
// Функция возвращает:
//  0  - ошибка (например точка вне документа, документ не лист и  );
//  -1 - в текущем документе нет разбиения на зоны;
//  1  - успешное завершение.
// ---
int LIB_FUNC ksGetZonaW( double x, double y,   //x,y - координаты точки в текущем документе;
                         LPWSTR zona,          //буфер для возврата зоны;
                         int    size );        //размер присланного буфера

#ifdef _UNICODE
#define ksGetZonaT  ksGetZonaW
#else
#define ksGetZonaT  ksGetZona
#endif // !_UNICODE


// Экспортный номер - 261
//------------------------------------------------------------------------------
// Функция очищает указанную область ( ограниченную группой или текущий вид ) в соответствии
// с границами группы grRegion.
// grClear  - группа геометрии, которую нужно очистить или 0 - просматривать все объекты текущего вида
// GrRegion - группа геометрии, представляющая область очистки
// ---
int LIB_FUNC ksClearRegion( reference grClear, reference grRegion, unsigned char inside  );

// Экспортный номер - 333
//------------------------------------------------------------------------------------------------
//  растянуть изображение активного окна на весь экран, ограниченное прямоугольником с
//  точками по диагонали  x1,y1, x2,y2 . Координаты точек в СК вида
//------------------------------------------------------------------------------------------------
int LIB_FUNC  ksZoom ( double x1, double y1, double x2, double y2 );

// Экспортный номер - 334
//------------------------------------------------------------------------------------------------
//  растянуть изображение активного окна на весь экран, ограниченное прямоугольником с центром
//  и масштабом . Координаты центра в СК вида
//------------------------------------------------------------------------------------------------
int  LIB_FUNC ksZoomScale ( double x, double y, double scale );

// Экспортный номер - 335
//------------------------------------------------------------------------------------------------
//  Отобразить предыдущие/следующие "окно" для активного документа или показать весь документ
//------------------------------------------------------------------------------------------------
int LIB_FUNC ksZoomPrevNextOrAll ( unsigned char type );//0- следующий Zoom,1- предыдущий Zoom,2-весь документ

// Экспортный номер - 385
//------------------------------------------------------------------------------
// Вернуть масштаб и ценр активного окна графического документа
// ---
int LIB_FUNC ksGetZoomScale ( double *x, double *y, double *scale ); //Координаты центра в СК вида и масштаб

// Экспортный номер - 337
//------------------------------------------------------------------------------------------------
//  обновить   активное  окно документа
//------------------------------------------------------------------------------------------------
int LIB_FUNC ksRefreshActiveWindow ( );

// Экспортный номер - 438
//------------------------------------------------------------------------------
// Проверить наличие видимых или невидимых участков на кривой
// Возвращает 1 в случае если в объекте состоит из видимых и невидимых участков
// ---
int LIB_FUNC IsVisibleOrHiddenArraysInObject( reference obj );

// Экспортный номер - 439
//------------------------------------------------------------------------------
// Возвращает 1 в случае если объект принадлежит ассоциативному виду.
// ---
int LIB_FUNC IsObjFromAssociativeView( reference obj );


// Экспортный номер - 440
//------------------------------------------------------------------------------
// Возвращает 1 в случае если объект геометрический
// ---
int LIB_FUNC IsGeomObject( reference obj );

// Экспортный номер - 280
//------------------------------------------------------------------------------
// Возвращает радиус окружности вписанной в ловушку курсора
// ---
double LIB_FUNC ksGetCursorLimit();

// Экспортный номер - 295
//-----------------------------------------------------------------------------
// Функция оставляет часть кривой между заданными точками.
// Если точки не лежат на кривой, они проецируются на кривую.
// deleteOldCurve - true кривая curve будет удалена после усечения,
//                  false кривая curve не будет удалена после усечения.
// Функция возвращает указатель на усеченную кривую, или 0 в случае неудачи.
//-----------------------------------------------------------------------------
reference LIB_FUNC ksTrimCurve( reference curve,          // кривая
															  double x1, double y1,     // первая точка
																double x2, double y2,     // вторая точка
                                double x3, double y3,     // третья точка
                                unsigned char deleteOldCurve );    // признак удаления старой кривой

// Экспортный номер - 299
//-------------------------------------------------------------------------------
// Печать документа.
// fileName - полное имя файла печатаемого документа,
// toFile   - имя файла в который выводить (*.prn, и т.д.), или NULL если нужно 
//            вывести сразу на принтер,
// scale    - масштаб, с которым нужно выводить документ
// Функция возвращает 0 в случае неудачи.
// ---
int LIB_FUNC ksPrintKompasDocument( const char * fileName, const char * toFile, double scale );


// Экспортный номер - 883
//-------------------------------------------------------------------------------
// Печать документа.
// fileName - полное имя файла печатаемого документа,
// toFile   - имя файла в который выводить (*.prn, и т.д.), или NULL если нужно 
//            вывести сразу на принтер,
// scale    - масштаб, с которым нужно выводить документ
// Функция возвращает 0 в случае неудачи. (Unicode)
// ---
int LIB_FUNC ksPrintKompasDocumentW( LPCWSTR fileName, LPCWSTR toFile, double scale );

#ifdef _UNICODE
#define ksPrintKompasDocumentT  ksPrintKompasDocumentW
#else
#define ksPrintKompasDocumentT  ksPrintKompasDocument
#endif // !UNICODE


// Экспортный номер - 981
//-------------------------------------------------------------------------------
// Печать документа.
// fileName - полное имя файла печатаемого документа,
// toFile   - имя файла в который выводить (*.prn, и т.д.), или NULL если нужно 
//            вывести сразу на принтер,
// scale    - масштаб, с которым нужно выводить документ
// fKompasPrint = 1 true используем принтер Компас, 0 - умолчательный принтер Windows
// Функция возвращает 0 в случае неудачи.
// ---
int LIB_FUNC ksPrintKompasDocumentEx( const char * fileName, const char * toFile, double scale, int fKompasPrinter );


// Экспортный номер - 982
//-------------------------------------------------------------------------------
// Печать документа.
// fileName - полное имя файла печатаемого документа,
// toFile   - имя файла в который выводить (*.prn, и т.д.), или NULL если нужно 
//            вывести сразу на принтер,
// scale    - масштаб, с которым нужно выводить документ
// fKompasPrint = 1 true используем принтер Компас, 0 - умолчательный принтер Windows
// Функция возвращает 0 в случае неудачи. (Unicode)
// ---
int LIB_FUNC ksPrintKompasDocumentExW( LPCWSTR fileName, LPCWSTR toFile, double scale, int fKompasPrinter );

#ifdef _UNICODE
#define ksPrintKompasDocumentExT  ksPrintKompasDocumentExW
#else
#define ksPrintKompasDocumentExT  ksPrintKompasDocumentEx
#endif // !UNICODE



// Экспортный номер - 702
//-------------------------------------------------------------------------------
// Получить длину полки и координаты  конца полки в системе координат вида
// для линии выноски, обозначения позиции, выносная надпись к многослойным конструкциям 
// и марка/позиционное обозначение с линией-выноской
// Функция возвращает 0 в случае неудачи.
//-------------------------------------------------------------------------------
double LIB_FUNC ksGetLeaderShelfLength( reference p,          //указатель линии выноски
                                       double *x, double *y ); //координаты конца полки
   

// Экспортный номер - 954
//-------------------------------------------------------------------------------
// Получить координаты начала или конца полки в системе координат вида
// для линии выноски, обозначения позиции, выносная надпись к многослойным конструкциям 
// и марка/позиционное обозначение с линией-выноской и размерам
//-------------------------------------------------------------------------------
int LIB_FUNC ksGetShelfPoint( reference p, int index, double *x, double *y, int paramType );


// Экспортный номер - 716
//-------------------------------------------------------------------------------
// Получить тип документа
// Функция возвращает тип документа DocType "ldefin2d.h" в случае успеха или 0 в случае неудачи
// ---
int LIB_FUNC ksGetDocumentType( reference doc );

// Экспортный номер - 722
//-------------------------------------------------------------------------------
// Функция возвращает тип документа DocType "ldefin2d.h" в случае успеха или 
// 0 в случае неудачи
//-------------------------------------------------------------------------------
int LIB_FUNC ksGetDocumentTypeByName( char * fileName );


// Экспортный номер - 884
//-------------------------------------------------------------------------------
// Функция возвращает тип документа DocType "ldefin2d.h" в случае успеха или 
// 0 в случае неудачи (Unicode)
//-------------------------------------------------------------------------------
int LIB_FUNC ksGetDocumentTypeByNameW( LPWSTR fileName );


#ifdef _UNICODE
#define ksGetDocumentTypeByNameT  ksGetDocumentTypeByNameW
#else
#define ksGetDocumentTypeByNameT  ksGetDocumentTypeByName
#endif // !UNICODE


// Экспортный номер - 725
//-----------------------------------------------------------------------------
// Подписаться на сообщение в COM
// ifType      - тип интерфейсов сообщений ksNotifyType
// object      - указатель интерфейса сообщений
// pContainer  - указатель на объект Компас, контейнер сообщений
// ---
int LIB_FUNC ksConnectionAdvise ( NotifyConnectionParam * param, LPUNKNOWN object );

// Экспортный номер - 726
//-----------------------------------------------------------------------------
// Снять подписку на сообщение в COM
// ifType      - тип интерфейсов сообщений ksNotifyType
// pContainer  - указатель на объект Компас, контейнер сообщений
// ---
int LIB_FUNC ksConnectionUnadvise ( NotifyConnectionParam * param );

//-------------------------------------------------------------------------------
// Изменить порядок объектов
// group - исходные объекты,
// obj - объект, относительно которого меняем порядок
// orderType - Тип изменения порядка объектов /*ChangeOrderType*/
// Возвращает 1 в случае успеха, и 0 - в случае неудачи
// ---
int LIB_FUNC ksChangeObjectsOrder( reference group, reference obj, int orderType );

// Экспортный номер - 736
// [17/5/2004] 
//-------------------------------------------------------------------------------
// Функция возвращает режим ортогонального черчения
// Используется только для визуальных документов
// Возвращаемое значение:
// 1 - режим ортогонального черчения включен, 0 - выключен
// Входные параметры:
// doc - указатель на документ
// ---
long LIB_FUNC ksGetOrthoMode( reference doc );

// Экспортный номер - 737
// [17/5/2004] 
//-------------------------------------------------------------------------------
// Изменить режим ортогонального черчения
// Используется только для визуальных документов
// Возвращаемое значение:
// 1 в случае успеха, 0 - в случае неудачи
// Входные параметры:
// doc - указатель на документ
// orthoMode - режим ортогонального черчения ( 1 - включить, 0 - выключить )
// ---
long LIB_FUNC ksSetOrthoMode( reference doc, long orthoMode );

// Экспортный номер - 741
// [26/5/2004] 
//-----------------------------------------------------------------------------
// Функция возвращает режим ожидания DblClick при редактировании макрообъекта 
// Возвращаемое значение:
// 1 - режим ожидания DblClick включен, 0 - выключен
// Входные параметры:
// ref - указатель на макроэлемент
// ---
extern "C" long LIB_FUNC ksGetMacroWaitDblClickEdit( reference ref );

// Экспортный номер - 742
// [26/5/2004] 
//-------------------------------------------------------------------------------
// Изменить режим ожидания DblClick при редактировании макрообъекта 
// Возвращаемое значение:
// 1 - в случае успеха, 0 - в случае неудачи
// Входные параметры:
// ref - указатель на макроэлемент
// waitDblClick - режим ожидания DblClick ( 1 - включить, 0 - выключить )
// ---
extern "C" long LIB_FUNC ksSetMacroWaitDblClickEdit( reference ref, long waitDblClick );

// Экспортный номер - 751
// [24/8/2004] 
//-------------------------------------------------------------------------------
// Получить интерфейс параметров параметризации объектов
// ---
IParametrizationParam* LIB_FUNC ksGetParametrizationParam();

// Экспортный номер - 740
// [24/8/2004] 
//-----------------------------------------------------------------------------
// Параметризовать объекты
// Если group = 0, параметризуется группа селектирования.
// Допуск на совпадение точек должен лежать в диапазоне [0..10] мм
// Угловой допуск должен лежать в диапазоне [0..10] гр
// Функция возвращает 1 в случае успеха и 0 в случае неудачи
//--- 
int LIB_FUNC ksParametrizeObjects( reference group,                // Указатель группы      
                                   IParametrizationParam* param ); // Параметры параметризации

// [20.06.2005]
// Экспортный номер - 763
//-------------------------------------------------------------------------------------------------
//  Для документа получить количество листов
//  pDoc = 0 - для текущего документаспецификации
//-------------------------------------------------------------------------------------------------
int LIB_FUNC ksGetDocumentPagesCount( reference pDoc );

// [08.08.2008]
// Экспортный номер - 985
//-------------------------------------------------------------------------------------------------
// Запуска процесса вставки фргамента из библиотеки
// fileName - полный путь к библиотеке и к фрагменту внутри неё.
//-------------------------------------------------------------------------------------------------
#ifndef __VIEWER_VERSION__
int LIB_FUNC ksLibDocumentInsertProc( LPSTR fileName );
#endif // __VIEWER_VERSION__

// [08.08.2008]
// Экспортный номер - 986
//-------------------------------------------------------------------------------------------------
// Запуска процесса вставки фргамента из библиотеки
// fileName - полный путь к библиотеке и к фрагменту внутри неё.
//  (Unicode)
//-------------------------------------------------------------------------------------------------
#ifndef __VIEWER_VERSION__
int LIB_FUNC ksLibDocumentInsertProcW( LPWSTR fileName );
#endif // __VIEWER_VERSION__

#ifdef _UNICODE
#define ksLibDocumentInsertProcT  ksLibDocumentInsertProcW
#else
#define ksLibDocumentInsertProcT  ksLibDocumentInsertProc
#endif // !UNICODE


// Экспортный номер - 999
//----------------------------------------------------------------------------------------------
// скопировать группу в документ.
// from - указатель на документ, откуда копируется группа 
// to   - указатель на документ, куда копируется группа 
// gr   - указатель на копию группы
//
// возвращает указатель на группу в документе to
// 
//----------------------------------------------------------------------------------------------
#ifndef __VIEWER_VERSION__
  reference LIB_FUNC CopyGroupToDocument( reference gr, reference from, reference to );
#endif // __VIEWER_VERSION__

// Экспортный номер - 1005
//--------------------------------------------------------------------------
//  Находится ли документ или вид в режиме редактирования макро
//  возвращает 1 - если визуальный режим редактирования макроэлемента
//             0-  обычный режим создания\редактирования объектов
//--------------------------------------------------------------------------
#ifndef __VIEWER_VERSION__
  int LIB_FUNC ksGetEditMacroVisibleRegime( reference p ); //указатель на 2D документ или вид,  0 - текущий документ
#endif // __VIEWER_VERSION__


// Экспортный номер - 1013
//-------------------------------------------------------------------------------
// Признак открытия файлов в режиме восстановления
// ---
int LIB_FUNC ksGetRecoverMode();

// Экспортный номер - 1014
//-------------------------------------------------------------------------------
// Признак открытия файлов в режиме восстановления
// ---
int LIB_FUNC ksSetRecoverMode( int mode );


// Экспортный номер - 1015
//-------------------------------------------------------------------------------
// Очистить признак ошибки после открытия файла с восстановлением
// ---
int LIB_FUNC ksClearRecoverError();

// Экспортный номер - 1016
//-------------------------------------------------------------------------------
// Получить признак ошибки после открытия файла с восстановлением
// ---
int LIB_FUNC ksGetRecoverError();

} // extern "C"

#endif // __LT_EDIT_H
